<?xml version="1.0" encoding="ASCII"?>
<!DOCTYPE instrs SYSTEM "AZ_Rules.dtd">
<!-- Copyright (c) 2016 Mahdi Safsafi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

 -->
<!--   https://github.com/MahdiSafsafi/Parsable-Instructions   -->
<!-- 
  This XML file includes all instructions found in :
  Intel 64 and IA-32 Architectures Software Developers Manuals Volume 2 document.
 -->
<!-- 
****KEY TO ABBREVIATIONS****
  x32m = 32-bit mode support.
  x64m = 64-bit mode support.
  mnem = Instruction Mnemonic.
  args = Instruction Arguments.
  opc  = Opcodes.
  openc = Operand Encoding.
  dscrp = Description.
  oprndenc = Instruction Operand Encoding.
  oprnd1 = Operand 1.
  oprnd2 = Operand 2.
  oprnd3 = Operand 3.
  oprnd4 = Operand 4.

****FOR THE REST OF KEYS YOU SHOULD REFER TO INTEL DOCUMENTATIONS!****
 -->
<instrs version="1.00">
	<common>
		<brief>AAA--ASCII Adjust After Addition.</brief>
		<ins x32m="V" x64m="I">
			<mnem>AAA</mnem>
			<args>void</args>
			<opc openc="NP">37</opc>
			<dscrp>ASCII adjust AL after addition.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AAD--ASCII Adjust AX Before Division.</brief>
		<ins x32m="V" x64m="I">
			<mnem>AAD</mnem>
			<args>void</args>
			<opc openc="NP">D5 0A</opc>
			<dscrp>ASCII adjust AX before division.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>AAD</mnem>
			<args>imm8</args>
			<opc openc="NP">D5 ib</opc>
			<dscrp>Adjust AX before division to number base imm8.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AAM--ASCII Adjust AX After Multiply.</brief>
		<ins x32m="V" x64m="I">
			<mnem>AAM</mnem>
			<args>void</args>
			<opc openc="NP">D4 0A</opc>
			<dscrp>ASCII adjust AX after multiply.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>AAM</mnem>
			<args>imm8</args>
			<opc openc="NP">D4 ib</opc>
			<dscrp>Adjust AX after multiply to number base imm8.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AAS--ASCII Adjust AL After Subtraction.</brief>
		<ins x32m="V" x64m="I">
			<mnem>AAS</mnem>
			<args>void</args>
			<opc openc="NP">3F</opc>
			<dscrp>ASCII adjust AL after subtraction.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADC--Add with Carry.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>AL,imm8</args>
			<opc openc="I">14 ib</opc>
			<dscrp>Add with carry imm8 to AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>AX,imm16</args>
			<opc openc="I">15 iw</opc>
			<dscrp>Add with carry imm16 to AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">15 id</opc>
			<dscrp>Add with carry imm32 to EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 15 id</opc>
			<dscrp>Add with carry imm32 sign extended to 64bits to RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m8,imm8*</args>
			<opc openc="MI">80 /2 ib</opc>
			<dscrp>Add with carry imm8 to r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">REX + 80 /2 ib</opc>
			<dscrp>Add with carry imm8 to r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /2 iw</opc>
			<dscrp>Add with carry imm16 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /2 id</opc>
			<dscrp>Add with CF imm32 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /2 id</opc>
			<dscrp>Add with CF imm32 sign extended to 64-bits to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /2 ib</opc>
			<dscrp>Add with CF sign-extended imm8 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /2 ib</opc>
			<dscrp>Add with CF sign-extended imm8 into r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /2 ib</opc>
			<dscrp>Add with CF sign-extended imm8 into r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m8,r8**</args>
			<opc openc="MR">10 /r</opc>
			<dscrp>Add with carry byte register to r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">REX + 10 /r</opc>
			<dscrp>Add with carry byte register to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">11 /r</opc>
			<dscrp>Add with carry r16 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">11 /r</opc>
			<dscrp>Add with CF r32 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 11 /r</opc>
			<dscrp>Add with CF r64 to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r8,r/m8**</args>
			<opc openc="RM">12 /r</opc>
			<dscrp>Add with carry r/m8 to byte register.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">REX + 12 /r</opc>
			<dscrp>Add with carry r/m64 to byte register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">13 /r</opc>
			<dscrp>Add with carry r/m16 to r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADC</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">13 /r</opc>
			<dscrp>Add with CF r/m32 to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADC</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 13 /r</opc>
			<dscrp>Add with CF r/m64 to r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADCX--Unsigned Integer Addition of Two Operands with Carry Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADCX</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">66 0F 38 F6 /r</opc>
			<cpuid>
				<flag>ADX</flag>
			</cpuid>
			<dscrp>Unsigned addition of r32 with CF, r/m32 to r32, writes CF.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADCX</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">66 REX.w 0F 38 F6 /r</opc>
			<cpuid>
				<flag>ADX</flag>
			</cpuid>
			<dscrp>Unsigned addition of r64 with CF, r/m64 to r64, writes CF.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADD--Add.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>AL,imm8</args>
			<opc openc="I">04 ib</opc>
			<dscrp>Add imm8 to AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>AX,imm16</args>
			<opc openc="I">05 iw</opc>
			<dscrp>Add imm16 to AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">05 id</opc>
			<dscrp>Add imm32 to EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 05 id</opc>
			<dscrp>Add imm32 sign-extended to 64-bits to RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m8,imm8*</args>
			<opc openc="MI">80 /0 ib</opc>
			<dscrp>Add imm8 to r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">REX + 80 /0 ib</opc>
			<dscrp>Add sign-extended imm8 to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /0 iw</opc>
			<dscrp>Add imm16 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /0 id</opc>
			<dscrp>Add imm32 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /0 id</opc>
			<dscrp>Add imm32 sign-extended to 64-bits to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /0 ib</opc>
			<dscrp>Add sign-extended imm8 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /0 ib</opc>
			<dscrp>Add sign-extended imm8 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /0 ib</opc>
			<dscrp>Add sign-extended imm8 to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m8,r8**</args>
			<opc openc="MR">00 /r</opc>
			<dscrp>Add r8 to r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">REX + 00 /r</opc>
			<dscrp>Add r8 to r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">01 /r</opc>
			<dscrp>Add r16 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">01 /r</opc>
			<dscrp>Add r32 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 01 /r</opc>
			<dscrp>Add r64 to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r8,r/m8**</args>
			<opc openc="RM">02 /r</opc>
			<dscrp>Add r/m8 to r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">REX + 02 /r</opc>
			<dscrp>Add r/m8 to r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">03 /r</opc>
			<dscrp>Add r/m16 to r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ADD</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">03 /r</opc>
			<dscrp>Add r/m32 to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADD</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 03 /r</opc>
			<dscrp>Add r/m64 to r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADDPD--Add Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADDPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 58 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed double-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 58 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 58 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADDPS--Add Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADDPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 58 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 58 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 58 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADDSD--Add Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADDSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 58 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add the low double-precision floating-point value from xmm2/m64 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 58 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADDSS--Add Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADDSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 58 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Add the low single-precision floating-point value from xmm2/m32 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 58 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADDSUBPD--Packed Double-FP Add/Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADDSUBPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D0 /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDSUBPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDSUBPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADDSUBPS--Packed Single-FP Add/Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADDSUBPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F2 0F D0 /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDSUBPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.F2.0F.WIG D0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VADDSUBPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.F2.0F.WIG D0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ADOX--Unsigned Integer Addition of Two Operands with Overflow Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ADOX</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">F3 0F 38 F6 /r</opc>
			<cpuid>
				<flag>ADX</flag>
			</cpuid>
			<dscrp>Unsigned addition of r32 with OF, r/m32 to r32, writes OF.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ADOX</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">F3 REX.w 0F 38 F6 /r</opc>
			<cpuid>
				<flag>ADX</flag>
			</cpuid>
			<dscrp>Unsigned addition of r64 with OF, r/m64 to r64, writes OF.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AESDEC--Perform One Round of an AES Decryption Flow.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AESDEC</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 DE /r</opc>
			<cpuid>
				<flag>AES</flag>
			</cpuid>
			<dscrp>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VAESDEC</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG DE /r</opc>
			<cpuid>
				<flag>AES</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AESDECLAST--Perform Last Round of an AES Decryption Flow.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AESDECLAST</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 DF /r</opc>
			<cpuid>
				<flag>AES</flag>
			</cpuid>
			<dscrp>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VAESDECLAST</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG DF /r</opc>
			<cpuid>
				<flag>AES</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AESENC--Perform One Round of an AES Encryption Flow.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AESENC</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 DC /r</opc>
			<cpuid>
				<flag>AES</flag>
			</cpuid>
			<dscrp>Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VAESENC</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG DC /r</opc>
			<cpuid>
				<flag>AES</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AESENCLAST--Perform Last Round of an AES Encryption Flow.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AESENCLAST</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 DD /r</opc>
			<cpuid>
				<flag>AES</flag>
			</cpuid>
			<dscrp>Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VAESENCLAST</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG DD /r</opc>
			<cpuid>
				<flag>AES</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AESIMC--Perform the AES InvMixColumn Transformation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AESIMC</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 DB /r</opc>
			<cpuid>
				<flag>AES</flag>
			</cpuid>
			<dscrp>Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VAESIMC</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG DB /r</opc>
			<cpuid>
				<flag>AES</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AESKEYGENASSIST--AES Round Key Generation Assist.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AESKEYGENASSIST</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A DF /r ib</opc>
			<cpuid>
				<flag>AES</flag>
			</cpuid>
			<dscrp>Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VAESKEYGENASSIST</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.WIG DF /r ib</opc>
			<cpuid>
				<flag>AES</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>AND--Logical AND.</brief>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>AL,imm8</args>
			<opc openc="I">24 ib</opc>
			<dscrp>AL AND imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>AX,imm16</args>
			<opc openc="I">25 iw</opc>
			<dscrp>AX AND imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">25 id</opc>
			<dscrp>EAX AND imm32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 25 id</opc>
			<dscrp>RAX AND imm32 sign-extended to 64-bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m8,imm8*</args>
			<opc openc="MI">80 /4 ib</opc>
			<dscrp>r/m8 AND imm8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">REX + 80 /4 ib</opc>
			<dscrp>r/m8 AND imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /4 iw</opc>
			<dscrp>r/m16 AND imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /4 id</opc>
			<dscrp>r/m32 AND imm32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /4 id</opc>
			<dscrp>r/m64 AND imm32 sign extended to 64-bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /4 ib</opc>
			<dscrp>r/m16 AND imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /4 ib</opc>
			<dscrp>r/m32 AND imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /4 ib</opc>
			<dscrp>r/m64 AND imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m8,r8**</args>
			<opc openc="MR">20 /r</opc>
			<dscrp>r/m8 AND r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">REX + 20 /r</opc>
			<dscrp>r/m64 AND r8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">21 /r</opc>
			<dscrp>r/m16 AND r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">21 /r</opc>
			<dscrp>r/m32 AND r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 21 /r</opc>
			<dscrp>r/m64 AND r32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r8,r/m8**</args>
			<opc openc="RM">22 /r</opc>
			<dscrp>r8 AND r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">REX + 22 /r</opc>
			<dscrp>r/m64 AND r8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">23 /r</opc>
			<dscrp>r16 AND r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>AND</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">23 /r</opc>
			<dscrp>r32 AND r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>AND</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 23 /r</opc>
			<dscrp>r64 AND r/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ANDN--Logical AND NOT.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ANDN</mnem>
			<args>r32a,r32b,r/m32</args>
			<opc openc="RVM">VEX.NDS.LZ.0F38.W0 F2 /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Bitwise AND of inverted r32b with r/m32, store result in r32a.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ANDN</mnem>
			<args>r64a,r64b,r/m64</args>
			<opc openc="RVM">VEX.NDS.LZ. 0F38.W1 F2 /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Bitwise AND of inverted r64b with r/m64, store result in r64a.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ANDPD--Bitwise Logical AND of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ANDPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 54 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 54 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 54 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ANDPS--Bitwise Logical AND of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ANDPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 54 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Bitwise logical AND of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 54 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 54 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ANDNPD--Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ANDNPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 55 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise logical AND NOT of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDNPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 55 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDNPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 55/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ANDNPS--Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ANDNPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 55 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Bitwise logical AND NOT of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDNPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 55 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VANDNPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 55 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ARPL--Adjust RPL Field of Segment Selector.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>ARPL</mnem>
			<args>r/m16,r16</args>
			<opc openc="NP">63 /r</opc>
			<dscrp>Adjust RPL of r/m16 to not less than RPL of r16.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLENDPD--Blend Packed Double Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLENDPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 0D /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDPD</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 0D /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Select packed double-precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDPD</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.WIG 0D /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Select packed double-precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)[3:0]</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BEXTR--Bit Field Extract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BEXTR</mnem>
			<args>r32a,r/m32,r32b</args>
			<opc openc="RMV">VEX.NDS.LZ.0F38.W0 F7 /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BEXTR</mnem>
			<args>r64a,r/m64,r64b</args>
			<opc openc="RMV">VEX.NDS.LZ.0F38.W1 F7 /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a.</dscrp>
		</ins>
		<oprndenc openc="RMV">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>VEX.vvvv(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLENDPS--Blend Packed Single Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLENDPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 0C /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDPS</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 0C /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDPS</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.WIG 0C /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLENDVPD--Variable Blend Packed Double Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLENDVPD</mnem>
			<args>xmm1,xmm2/m128,&lt;XMM0&gt;</args>
			<opc openc="RM0">66 0F 38 15 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDVPD</mnem>
			<args>xmm1,xmm2,xmm3/m128,xmm4</args>
			<opc openc="RVMR">VEX.NDS.128.66.0F3A.W0 4B /r /is4</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally copy double-precision floatingpoint values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDVPD</mnem>
			<args>ymm1,ymm2,ymm3/m256,ymm4</args>
			<opc openc="RVMR">VEX.NDS.256.66.0F3A.W0 4B /r /is4</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally copy double-precision floatingpoint values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4.</dscrp>
		</ins>
		<oprndenc openc="RM0">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>implicit XMM0</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMR">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)[7:4]</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLENDVPS--Variable Blend Packed Single Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLENDVPS</mnem>
			<args>xmm1,xmm2/m128,&lt;XMM0&gt;</args>
			<opc openc="RM0">66 0F 38 14 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDVPS</mnem>
			<args>xmm1,xmm2,xmm3/m128,xmm4</args>
			<opc openc="RVMR">VEX.NDS.128.66.0F3A.W0 4A /r /is4</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally copy single-precision floatingpoint values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBLENDVPS</mnem>
			<args>ymm1,ymm2,ymm3/m256,ymm4</args>
			<opc openc="RVMR">VEX.NDS.256.66.0F3A.W0 4A /r /is4</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally copy single-precision floatingpoint values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.</dscrp>
		</ins>
		<oprndenc openc="RM0">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>implicit XMM0</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMR">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)[7:4]</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLSI--Extract Lowest Set Isolated Bit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLSI</mnem>
			<args>r32,r/m32</args>
			<opc openc="VM">VEX.NDD.LZ.0F38.W0 F3 /3</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Extract lowest set bit from r/m32 and set that bit in r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BLSI</mnem>
			<args>r64,r/m64</args>
			<opc openc="VM">VEX.NDD.LZ.0F38.W1 F3 /3</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Extract lowest set bit from r/m64, and set that bit in r64.</dscrp>
		</ins>
		<oprndenc openc="VM">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLSMSK--Get Mask Up to Lowest Set Bit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLSMSK</mnem>
			<args>r32,r/m32</args>
			<opc openc="VM">VEX.NDD.LZ.0F38.W0 F3 /2</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Set all lower bits in r32 to '1' starting from bit 0 to lowest set bit in r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BLSMSK</mnem>
			<args>r64,r/m64</args>
			<opc openc="VM">VEX.NDD.LZ.0F38.W1 F3 /2</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Set all lower bits in r64 to '1' starting from bit 0 to lowest set bit in r/m64.</dscrp>
		</ins>
		<oprndenc openc="VM">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BLSR--Reset Lowest Set Bit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BLSR</mnem>
			<args>r32,r/m32</args>
			<opc openc="VM">VEX.NDD.LZ.0F38.W0 F3 /1</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BLSR</mnem>
			<args>r64,r/m64</args>
			<opc openc="VM">VEX.NDD.LZ.0F38.W1 F3 /1</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.</dscrp>
		</ins>
		<oprndenc openc="VM">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BNDCL--Check Lower Bound.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>BNDCL</mnem>
			<args>bnd,r/m32</args>
			<opc openc="RM">F3 0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Generate a #BR if the address in r/m32 is lower than the lower bound in bnd.LB.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BNDCL</mnem>
			<args>bnd,r/m64</args>
			<opc openc="RM">F3 0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Generate a #BR if the address in r/m64 is lower than the lower bound in bnd.LB.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BNDCU/BNDCN--Check Upper Bound.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>BNDCU</mnem>
			<args>bnd,r/m32</args>
			<opc openc="RM">F2 0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BNDCU</mnem>
			<args>bnd,r/m64</args>
			<opc openc="RM">F2 0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>BNDCN</mnem>
			<args>bnd,r/m32</args>
			<opc openc="RM">F2 0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BNDCN</mnem>
			<args>bnd,r/m64</args>
			<opc openc="RM">F2 0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BNDLDX--Load Extended Bounds Using Address Translation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BNDLDX</mnem>
			<args>bnd,mib</args>
			<opc openc="RM">0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>SIB.base(r): Address of pointer,SIB.index(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BNDMK--Make Bounds.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>BNDMK</mnem>
			<args>bnd,m32</args>
			<opc openc="RM">F3 0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Make lower and upper bounds from m32 and store them in bnd.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BNDMK</mnem>
			<args>bnd,m64</args>
			<opc openc="RM">F3 0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Make lower and upper bounds from m64 and store them in bnd.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BNDMOV--Move Bounds.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>BNDMOV</mnem>
			<args>bnd1,bnd2/m64</args>
			<opc openc="RM">66 0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Move lower and upper bound from bnd2/m64 to bound register bnd1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BNDMOV</mnem>
			<args>bnd1,bnd2/m128</args>
			<opc openc="RM">66 0F 1A /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Move lower and upper bound from bnd2/m128 to bound register bnd1.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>BNDMOV</mnem>
			<args>bnd1/m64,bnd2</args>
			<opc openc="MR">66 0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Move lower and upper bound from bnd2 to bnd1/m64.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BNDMOV</mnem>
			<args>bnd1/m128,bnd2</args>
			<opc openc="MR">66 0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Move lower and upper bound from bnd2 to bound register bnd1/m128.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BNDSTX--Store Extended Bounds Using Address Translation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BNDSTX</mnem>
			<args>mib,bnd</args>
			<opc openc="MR">0F 1B /r</opc>
			<cpuid>
				<flag>MPX</flag>
			</cpuid>
			<dscrp>Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>SIB.base(r): Address of pointer,SIB.index(r)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BOUND--Check Array Index Against Bounds.</brief>
		<ins x32m="V" x64m="I">
			<mnem>BOUND</mnem>
			<args>r16,m16&amp;16</args>
			<opc openc="RM">62 /r</opc>
			<dscrp>Check if r16 (array index) is within bounds specified by m16&amp;16.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>BOUND</mnem>
			<args>r32,m32&amp;32</args>
			<opc openc="RM">62 /r</opc>
			<dscrp>Check if r32 (array index) is within bounds specified by m32&amp;32.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BSF--Bit Scan Forward.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BSF</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F BC /r</opc>
			<dscrp>Bit scan forward on r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BSF</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F BC /r</opc>
			<dscrp>Bit scan forward on r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BSF</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F BC /r</opc>
			<dscrp>Bit scan forward on r/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BSR--Bit Scan Reverse.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BSR</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F BD /r</opc>
			<dscrp>Bit scan reverse on r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BSR</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F BD /r</opc>
			<dscrp>Bit scan reverse on r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BSR</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F BD /r</opc>
			<dscrp>Bit scan reverse on r/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BSWAP--Byte Swap.</brief>
		<ins x32m="V" x64m="V*">
			<mnem>BSWAP</mnem>
			<args>r32</args>
			<opc openc="O">0F C8+rd</opc>
			<dscrp>Reverses the byte order of a 32-bit register.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BSWAP</mnem>
			<args>r64</args>
			<opc openc="O">REX.W + 0F C8+rd</opc>
			<dscrp>Reverses the byte order of a 64-bit register.</dscrp>
		</ins>
		<oprndenc openc="O">
			<oprnd1>opcode + rd(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BT--Bit Test.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BT</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">0F A3 /r</opc>
			<dscrp>Store selected bit in CF flag.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BT</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">0F A3 /r</opc>
			<dscrp>Store selected bit in CF flag.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BT</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 0F A3 /r</opc>
			<dscrp>Store selected bit in CF flag.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BT</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">0F BA /4 ib</opc>
			<dscrp>Store selected bit in CF flag.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BT</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">0F BA /4 ib</opc>
			<dscrp>Store selected bit in CF flag.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BT</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 0F BA /4 ib</opc>
			<dscrp>Store selected bit in CF flag.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BTC--Bit Test and Complement.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BTC</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">0F BB /r</opc>
			<dscrp>Store selected bit in CF flag and complement.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTC</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">0F BB /r</opc>
			<dscrp>Store selected bit in CF flag and complement.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BTC</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 0F BB /r</opc>
			<dscrp>Store selected bit in CF flag and complement.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTC</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">0F BA /7 ib</opc>
			<dscrp>Store selected bit in CF flag and complement.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTC</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">0F BA /7 ib</opc>
			<dscrp>Store selected bit in CF flag and complement.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BTC</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 0F BA /7 ib</opc>
			<dscrp>Store selected bit in CF flag and complement.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BTR--Bit Test and Reset.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BTR</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">0F B3 /r</opc>
			<dscrp>Store selected bit in CF flag and clear.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTR</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">0F B3 /r</opc>
			<dscrp>Store selected bit in CF flag and clear.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BTR</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 0F B3 /r</opc>
			<dscrp>Store selected bit in CF flag and clear.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">0F BA /6 ib</opc>
			<dscrp>Store selected bit in CF flag and clear.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">0F BA /6 ib</opc>
			<dscrp>Store selected bit in CF flag and clear.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BTR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 0F BA /6 ib</opc>
			<dscrp>Store selected bit in CF flag and clear.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BTS--Bit Test and Set.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BTS</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">0F AB /r</opc>
			<dscrp>Store selected bit in CF flag and set.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTS</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">0F AB /r</opc>
			<dscrp>Store selected bit in CF flag and set.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BTS</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 0F AB /r</opc>
			<dscrp>Store selected bit in CF flag and set.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTS</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">0F BA /5 ib</opc>
			<dscrp>Store selected bit in CF flag and set.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>BTS</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">0F BA /5 ib</opc>
			<dscrp>Store selected bit in CF flag and set.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BTS</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 0F BA /5 ib</opc>
			<dscrp>Store selected bit in CF flag and set.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>BZHI--Zero High Bits Starting with Specified Bit Position.</brief>
		<ins x32m="V" x64m="V">
			<mnem>BZHI</mnem>
			<args>r32a,r/m32,r32b</args>
			<opc openc="RMV">VEX.NDS.LZ.0F38.W0 F5 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Zero bits in r/m32 starting with the position in r32b, write result to r32a.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>BZHI</mnem>
			<args>r64a,r/m64,r64b</args>
			<opc openc="RMV">VEX.NDS.LZ.0F38.W1 F5 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Zero bits in r/m64 starting with the position in r64b, write result to r64a.</dscrp>
		</ins>
		<oprndenc openc="RMV">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>VEX.vvvv(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CALL--Call Procedure.</brief>
		<ins x32m="V" x64m="NS">
			<mnem>CALL</mnem>
			<args>rel16</args>
			<opc openc="M">E8 cw</opc>
			<dscrp>Call near, relative, displacement relative to next instruction.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CALL</mnem>
			<args>rel32</args>
			<opc openc="M">E8 cd</opc>
			<dscrp>Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>CALL</mnem>
			<args>r/m16</args>
			<opc openc="M">FF /2</opc>
			<dscrp>Call near, absolute indirect, address given in r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>CALL</mnem>
			<args>r/m32</args>
			<opc openc="M">FF /2</opc>
			<dscrp>Call near, absolute indirect, address given in r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CALL</mnem>
			<args>r/m64</args>
			<opc openc="M">FF /2</opc>
			<dscrp>Call near, absolute indirect, address given in r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>CALL</mnem>
			<args>ptr16:16</args>
			<opc openc="D">9A cd</opc>
			<dscrp>Call far, absolute, address given in operand.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>CALL</mnem>
			<args>ptr16:32</args>
			<opc openc="D">9A cp</opc>
			<dscrp>Call far, absolute, address given in operand.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CALL</mnem>
			<args>m16:16</args>
			<opc openc="M">FF /3</opc>
			<dscrp>Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16instruction.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CALL</mnem>
			<args>m16:32</args>
			<opc openc="M">FF /3</opc>
			<dscrp>In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CALL</mnem>
			<args>m16:64</args>
			<opc openc="M">REX.W + FF /3</opc>
			<dscrp>In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction.</dscrp>
		</ins>
		<oprndenc openc="D">
			<oprnd1>Offset</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CBW/CWDE/CDQE--Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CBW</mnem>
			<args>void</args>
			<opc openc="NP">98</opc>
			<dscrp>AX &lt;-- sign-extend of AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CWDE</mnem>
			<args>void</args>
			<opc openc="NP">98</opc>
			<dscrp>EAX &lt;-- sign-extend of AX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CDQE</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + 98</opc>
			<dscrp>RAX &lt;-- sign-extend of EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CLAC--Clear AC Flag in EFLAGS Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CLAC</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 CA</opc>
			<dscrp>Clear the AC flag in the EFLAGS register.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CLC--Clear Carry Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CLC</mnem>
			<args>void</args>
			<opc openc="NP">F8</opc>
			<dscrp>Clear CF flag.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CLD--Clear Direction Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CLD</mnem>
			<args>void</args>
			<opc openc="NP">FC</opc>
			<dscrp>Clear DF flag.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CLFLUSH--Flush Cache Line.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CLFLUSH</mnem>
			<args>m8</args>
			<opc openc="M">0F AE /7</opc>
			<dscrp>Flushes cache line containing m8.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CLI--Clear Interrupt Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CLI</mnem>
			<args>void</args>
			<opc openc="NP">FA</opc>
			<dscrp>Clear interrupt flag; interrupts disabled when interrupt flag cleared.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CLTS--Clear Task-Switched Flag in CR0.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CLTS</mnem>
			<args>void</args>
			<opc openc="NP">0F 06</opc>
			<dscrp>Clears TS flag in CR0.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMC--Complement Carry Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMC</mnem>
			<args>void</args>
			<opc openc="NP">F5</opc>
			<dscrp>Complement CF flag.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMOVcc--Conditional Move.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMOVA</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 47 /r</opc>
			<dscrp>Move if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVA</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 47 /r</opc>
			<dscrp>Move if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVA</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 47 /r</opc>
			<dscrp>Move if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVAE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 43 /r</opc>
			<dscrp>Move if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVAE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 43 /r</opc>
			<dscrp>Move if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVAE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 43 /r</opc>
			<dscrp>Move if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVB</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 42 /r</opc>
			<dscrp>Move if below (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVB</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 42 /r</opc>
			<dscrp>Move if below (CF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVB</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 42 /r</opc>
			<dscrp>Move if below (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVBE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 46 /r</opc>
			<dscrp>Move if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVBE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 46 /r</opc>
			<dscrp>Move if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVBE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 46 /r</opc>
			<dscrp>Move if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVC</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 42 /r</opc>
			<dscrp>Move if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVC</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 42 /r</opc>
			<dscrp>Move if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVC</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 42 /r</opc>
			<dscrp>Move if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 44 /r</opc>
			<dscrp>Move if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 44 /r</opc>
			<dscrp>Move if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 44 /r</opc>
			<dscrp>Move if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVG</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4F /r</opc>
			<dscrp>Move if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVG</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4F /r</opc>
			<dscrp>Move if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVG</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4F /r</opc>
			<dscrp>Move if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVGE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4D /r</opc>
			<dscrp>Move if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVGE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4D /r</opc>
			<dscrp>Move if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVGE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4D /r</opc>
			<dscrp>Move if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVL</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4C /r</opc>
			<dscrp>Move if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVL</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4C /r</opc>
			<dscrp>Move if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVL</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4C /r</opc>
			<dscrp>Move if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVLE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4E /r</opc>
			<dscrp>Move if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVLE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4E /r</opc>
			<dscrp>Move if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVLE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4E /r</opc>
			<dscrp>Move if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNA</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 46 /r</opc>
			<dscrp>Move if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNA</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 46 /r</opc>
			<dscrp>Move if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNA</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 46 /r</opc>
			<dscrp>Move if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNAE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 42 /r</opc>
			<dscrp>Move if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNAE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 42 /r</opc>
			<dscrp>Move if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNAE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 42 /r</opc>
			<dscrp>Move if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNB</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 43 /r</opc>
			<dscrp>Move if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNB</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 43 /r</opc>
			<dscrp>Move if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNB</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 43 /r</opc>
			<dscrp>Move if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNBE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 47 /r</opc>
			<dscrp>Move if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNBE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 47 /r</opc>
			<dscrp>Move if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNBE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 47 /r</opc>
			<dscrp>Move if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNC</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 43 /r</opc>
			<dscrp>Move if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNC</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 43 /r</opc>
			<dscrp>Move if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNC</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 43 /r</opc>
			<dscrp>Move if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 45 /r</opc>
			<dscrp>Move if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 45 /r</opc>
			<dscrp>Move if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 45 /r</opc>
			<dscrp>Move if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNG</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4E /r</opc>
			<dscrp>Move if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNG</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4E /r</opc>
			<dscrp>Move if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNG</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4E /r</opc>
			<dscrp>Move if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNGE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4C /r</opc>
			<dscrp>Move if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNGE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4C /r</opc>
			<dscrp>Move if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNGE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4C /r</opc>
			<dscrp>Move if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNL</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4D /r</opc>
			<dscrp>Move if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNL</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4D /r</opc>
			<dscrp>Move if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNL</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4D /r</opc>
			<dscrp>Move if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNLE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4F /r</opc>
			<dscrp>Move if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNLE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4F /r</opc>
			<dscrp>Move if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNLE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4F /r</opc>
			<dscrp>Move if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNO</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 41 /r</opc>
			<dscrp>Move if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNO</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 41 /r</opc>
			<dscrp>Move if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNO</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 41 /r</opc>
			<dscrp>Move if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNP</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4B /r</opc>
			<dscrp>Move if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNP</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4B /r</opc>
			<dscrp>Move if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNP</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4B /r</opc>
			<dscrp>Move if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNS</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 49 /r</opc>
			<dscrp>Move if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNS</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 49 /r</opc>
			<dscrp>Move if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNS</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 49 /r</opc>
			<dscrp>Move if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNZ</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 45 /r</opc>
			<dscrp>Move if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVNZ</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 45 /r</opc>
			<dscrp>Move if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVNZ</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 45 /r</opc>
			<dscrp>Move if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVO</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 40 /r</opc>
			<dscrp>Move if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVO</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 40 /r</opc>
			<dscrp>Move if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVO</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 40 /r</opc>
			<dscrp>Move if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVP</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4A /r</opc>
			<dscrp>Move if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVP</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4A /r</opc>
			<dscrp>Move if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVP</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4A /r</opc>
			<dscrp>Move if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVPE</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4A /r</opc>
			<dscrp>Move if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVPE</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4A /r</opc>
			<dscrp>Move if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVPE</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4A /r</opc>
			<dscrp>Move if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVPO</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 4B /r</opc>
			<dscrp>Move if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVPO</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 4B /r</opc>
			<dscrp>Move if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVPO</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 4B /r</opc>
			<dscrp>Move if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVS</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 48 /r</opc>
			<dscrp>Move if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVS</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 48 /r</opc>
			<dscrp>Move if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVS</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 48 /r</opc>
			<dscrp>Move if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVZ</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F 44 /r</opc>
			<dscrp>Move if zero (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMOVZ</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F 44 /r</opc>
			<dscrp>Move if zero (ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMOVZ</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F 44 /r</opc>
			<dscrp>Move if zero (ZF=1).</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMP--Compare Two Operands.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>AL,imm8</args>
			<opc openc="I">3C ib</opc>
			<dscrp>Compare imm8 with AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>AX,imm16</args>
			<opc openc="I">3D iw</opc>
			<dscrp>Compare imm16 with AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">3D id</opc>
			<dscrp>Compare imm32 with EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 3D id</opc>
			<dscrp>Compare imm32 sign-extended to 64-bits with RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m8,imm8*</args>
			<opc openc="MI">80 /7 ib</opc>
			<dscrp>Compare imm8 with r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">REX + 80 /7 ib</opc>
			<dscrp>Compare imm8 with r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /7 iw</opc>
			<dscrp>Compare imm16 with r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /7 id</opc>
			<dscrp>Compare imm32 with r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /7 id</opc>
			<dscrp>Compare imm32 sign-extended to 64-bits with r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /7 ib</opc>
			<dscrp>Compare imm8 with r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /7 ib</opc>
			<dscrp>Compare imm8 with r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /7 ib</opc>
			<dscrp>Compare imm8 with r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m8,r8**</args>
			<opc openc="MR">38 /r</opc>
			<dscrp>Compare r8 with r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">REX + 38 /r</opc>
			<dscrp>Compare r8 with r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">39 /r</opc>
			<dscrp>Compare r16 with r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">39 /r</opc>
			<dscrp>Compare r32 with r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 39 /r</opc>
			<dscrp>Compare r64 with r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r8,r/m8**</args>
			<opc openc="RM">3A /r</opc>
			<dscrp>Compare r/m8 with r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">REX + 3A /r</opc>
			<dscrp>Compare r/m8 with r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">3B /r</opc>
			<dscrp>Compare r/m16 with r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMP</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">3B /r</opc>
			<dscrp>Compare r/m32 with r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMP</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 3B /r</opc>
			<dscrp>Compare r/m64 with r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX(r)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPPD--Compare Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMPPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F C2 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed double-precision floatingpoint values in xmm2/m128 and xmm1 using imm8 as comparison predicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCMPPD</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F.WIG C2 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed double-precision floatingpoint values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCMPPD</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F.WIG C2 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed double-precision floatingpoint values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPPS--Compare Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMPPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">0F C2 /r ib</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare packed single-precision floatingpoint values in xmm2/mem and xmm1 using imm8 as comparison predicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCMPPS</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.0F.WIG C2 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed single-precision floatingpoint values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCMPPS</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.0F.WIG C2 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed single-precision floatingpoint values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPS/CMPSB/CMPSW/CMPSD/CMPSQ--Compare String Operands.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMPS</mnem>
			<args>m8,m8</args>
			<opc openc="NP">A6</opc>
			<dscrp>For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64byte at address (R|E)DI. The status flags are set accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMPS</mnem>
			<args>m16,m16</args>
			<opc openc="NP">A7</opc>
			<dscrp>For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64word at address (R|E)DI. The status flags are set accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMPS</mnem>
			<args>m32,m32</args>
			<opc openc="NP">A7</opc>
			<dscrp>For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64dword at address (R|E)DI. The status flags are set accordingly.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMPS</mnem>
			<args>m64,m64</args>
			<opc openc="NP">REX.W + A7</opc>
			<dscrp>Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMPSB</mnem>
			<args>void</args>
			<opc openc="NP">A6</opc>
			<dscrp>For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64byte at address (R|E)DI. The status flags are set accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMPSW</mnem>
			<args>void</args>
			<opc openc="NP">A7</opc>
			<dscrp>For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64word at address (R|E)DI. The status flags are set accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CMPSD</mnem>
			<args>void</args>
			<opc openc="NP">A7</opc>
			<dscrp>For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMPSQ</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + A7</opc>
			<dscrp>Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPSD--Compare Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMPSD</mnem>
			<args>xmm1,xmm2/m64,imm8</args>
			<opc openc="RMI">F2 0F C2 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCMPSD</mnem>
			<args>xmm1,xmm2,xmm3/m64,imm8</args>
			<opc openc="RVMI">VEX.NDS.LIG.F2.0F.WIG C2 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPSS--Compare Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CMPSS</mnem>
			<args>xmm1,xmm2/m32,imm8</args>
			<opc openc="RMI">F3 0F C2 /r ib</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCMPSS</mnem>
			<args>xmm1,xmm2,xmm3/m32,imm8</args>
			<opc openc="RVMI">VEX.NDS.LIG.F3.0F.WIG C2 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPXCHG--Compare and Exchange.</brief>
		<ins x32m="V*" x64m="V">
			<mnem>CMPXCHG</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">0F B0/r</opc>
			<dscrp>Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMPXCHG</mnem>
			<args>r/m8**,r8</args>
			<opc openc="MR">REX + 0F B0/r</opc>
			<dscrp>Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.</dscrp>
		</ins>
		<ins x32m="V*" x64m="V">
			<mnem>CMPXCHG</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">0F B1/r</opc>
			<dscrp>Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.</dscrp>
		</ins>
		<ins x32m="V*" x64m="V">
			<mnem>CMPXCHG</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">0F B1/r</opc>
			<dscrp>Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMPXCHG</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 0F B1/r</opc>
			<dscrp>Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CMPXCHG8B/CMPXCHG16B--Compare and Exchange Bytes.</brief>
		<ins x32m="V*" x64m="V">
			<mnem>CMPXCHG8B</mnem>
			<args>m64</args>
			<opc openc="M">0F C7 / 1 m64</opc>
			<dscrp>Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CMPXCHG16B</mnem>
			<args>m128</args>
			<opc openc="M">REX.W + 0F C7 / 1 m128</opc>
			<dscrp>Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>COMISD--Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS.</brief>
		<ins x32m="V" x64m="V">
			<mnem>COMISD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0F 2F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCOMISD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.LIG.66.0F.WIG 2F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>COMISS--Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS.</brief>
		<ins x32m="V" x64m="V">
			<mnem>COMISS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">0F 2F /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCOMISS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.LIG.0F.WIG 2F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CPUID--CPU Identification.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CPUID</mnem>
			<args>void</args>
			<opc openc="NP">0F A2</opc>
			<dscrp>Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CRC32--Accumulate CRC32 Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CRC32</mnem>
			<args>r32,r/m8</args>
			<opc openc="RM">F2 0F 38 F0 /r</opc>
			<dscrp>Accumulate CRC32 on r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CRC32</mnem>
			<args>r32,r/m8*</args>
			<opc openc="RM">F2 REX 0F 38 F0 /r</opc>
			<dscrp>Accumulate CRC32 on r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CRC32</mnem>
			<args>r32,r/m16</args>
			<opc openc="RM">F2 0F 38 F1 /r</opc>
			<dscrp>Accumulate CRC32 on r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CRC32</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">F2 0F 38 F1 /r</opc>
			<dscrp>Accumulate CRC32 on r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CRC32</mnem>
			<args>r64,r/m8</args>
			<opc openc="RM">F2 REX.W 0F 38 F0 /r</opc>
			<dscrp>Accumulate CRC32 on r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CRC32</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">F2 REX.W 0F 38 F1 /r</opc>
			<dscrp>Accumulate CRC32 on r/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTDQ2PD--Convert Packed Dword Integers to Packed Double-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTDQ2PD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F3 0F E6</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTDQ2PD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.F3.0F.WIG E6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTDQ2PD</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.F3.0F.WIG E6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed signed doubleword integers from xmm2/mem to four packed double-precision floating-point values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTDQ2PS--Convert Packed Dword Integers to Packed Single-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTDQ2PS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 5B /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTDQ2PS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.0F.WIG 5B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTDQ2PS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.0F.WIG 5B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPD2DQ--Convert Packed Double-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPD2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F2 0F E6 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert two packed double-precision floatingpoint values from xmm2/m128 to two packed signed doubleword integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPD2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.F2.0F.WIG E6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert two packed double-precision floatingpoint values in xmm2/mem to two signed doubleword integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPD2DQ</mnem>
			<args>xmm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.F2.0F.WIG E6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed double-precision floatingpoint values in ymm2/mem to four signed doubleword integers in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPD2PI--Convert Packed Double-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPD2PI</mnem>
			<args>mm,xmm/m128</args>
			<opc openc="RM">66 0F 2D /r</opc>
			<dscrp>Convert two packed double-precision floatingpoint values from xmm/m128 to two packed signed doubleword integers in mm.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPD2PS--Convert Packed Double-Precision FP Values to Packed Single-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPD2PS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 5A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert two packed double-precision floatingpoint values in xmm2/m128 to two packed single-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPD2PS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG 5A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert two packed double-precision floatingpoint values in xmm2/mem to two singleprecision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPD2PS</mnem>
			<args>xmm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG 5A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed double-precision floatingpoint values in ymm2/mem to four singleprecision floating-point values in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPI2PD--Convert Packed Dword Integers to Packed Double-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPI2PD</mnem>
			<args>xmm,mm/m64*</args>
			<opc openc="RM">66 0F 2A /r</opc>
			<dscrp>Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPI2PS--Convert Packed Dword Integers to Packed Single-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPI2PS</mnem>
			<args>xmm,mm/m64</args>
			<opc openc="RM">0F 2A /r</opc>
			<dscrp>Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPS2DQ--Convert Packed Single-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPS2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 5B /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert four packed single-precision floatingpoint values from xmm2/m128 to four packed signed doubleword integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPS2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG 5B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed single precision floatingpoint values from xmm2/mem to four packed signed doubleword values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPS2DQ</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG 5B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert eight packed single precision floatingpoint values from ymm2/mem to eight packed signed doubleword values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPS2PD--Convert Packed Single-Precision FP Values to Packed Double-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPS2PD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">0F 5A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert two packed single-precision floatingpoint values in xmm2/m64 to two packed double-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPS2PD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.0F.WIG 5A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert two packed single-precision floatingpoint values in xmm2/mem to two packed double-precision floating-point values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPS2PD</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.0F.WIG 5A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed single-precision floatingpoint values in xmm2/mem to four packed double-precision floating-point values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTPS2PI--Convert Packed Single-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTPS2PI</mnem>
			<args>mm,xmm/m64</args>
			<opc openc="RM">0F 2D /r</opc>
			<dscrp>Convert two packed single-precision floatingpoint values from xmm/m64 to two packed signed doubleword integers in mm.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTSD2SI--Convert Scalar Double-Precision FP Value to Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTSD2SI</mnem>
			<args>r32,xmm/m64</args>
			<opc openc="RM">F2 0F 2D /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CVTSD2SI</mnem>
			<args>r64,xmm/m64</args>
			<opc openc="RM">F2 REX.W 0F 2D /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTSD2SI</mnem>
			<args>r32,xmm1/m64</args>
			<opc openc="RM">VEX.LIG.F2.0F.W0 2D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32.</dscrp>
		</ins>
		<ins x32m="NE1" x64m="V">
			<mnem>VCVTSD2SI</mnem>
			<args>r64,xmm1/m64</args>
			<opc openc="RM">VEX.LIG.F2.0F.W1 2D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTSD2SS--Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTSD2SS</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 5A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTSD2SS</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 5A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTSI2SD--Convert Dword Integer to Scalar Double-Precision FP Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTSI2SD</mnem>
			<args>xmm,r/m32</args>
			<opc openc="RM">F2 0F 2A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CVTSI2SD</mnem>
			<args>xmm,r/m64</args>
			<opc openc="RM">F2 REX.W 0F 2A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTSI2SD</mnem>
			<args>xmm1,xmm2,r/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.W0 2A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1.</dscrp>
		</ins>
		<ins x32m="NE1" x64m="V">
			<mnem>VCVTSI2SD</mnem>
			<args>xmm1,xmm2,r/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.W1 2A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTSI2SS--Convert Dword Integer to Scalar Single-Precision FP Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTSI2SS</mnem>
			<args>xmm,r/m32</args>
			<opc openc="RM">F3 0F 2A /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CVTSI2SS</mnem>
			<args>xmm,r/m64</args>
			<opc openc="RM">F3 REX.W 0F 2A /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTSI2SS</mnem>
			<args>xmm1,xmm2,r/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.W0 2A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1.</dscrp>
		</ins>
		<ins x32m="NE1" x64m="V">
			<mnem>VCVTSI2SS</mnem>
			<args>xmm1,xmm2,r/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.W1 2A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTSS2SD--Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTSS2SD</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 5A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTSS2SD</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 5A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTSS2SI--Convert Scalar Single-Precision FP Value to Dword Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTSS2SI</mnem>
			<args>r32,xmm/m32</args>
			<opc openc="RM">F3 0F 2D /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CVTSS2SI</mnem>
			<args>r64,xmm/m32</args>
			<opc openc="RM">F3 REX.W 0F 2D /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTSS2SI</mnem>
			<args>r32,xmm1/m32</args>
			<opc openc="RM">VEX.LIG.F3.0F.W0 2D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.</dscrp>
		</ins>
		<ins x32m="NE1" x64m="V">
			<mnem>VCVTSS2SI</mnem>
			<args>r64,xmm1/m32</args>
			<opc openc="RM">VEX.LIG.F3.0F.W1 2D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTTPD2DQ--Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTTPD2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E6 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert two packed double-precision floatingpoint values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTTPD2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG E6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert two packed double-precision floatingpoint values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTTPD2DQ</mnem>
			<args>xmm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG E6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed double-precision floatingpoint values in ymm2/mem to four signed doubleword integers in xmm1 using truncation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTTPD2PI--Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTTPD2PI</mnem>
			<args>mm,xmm/m128</args>
			<opc openc="RM">66 0F 2C /r</opc>
			<dscrp>Convert two packer double-precision floatingpoint values from xmm/m128 to two packed signed doubleword integers in mm using truncation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTTPS2DQ--Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTTPS2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F3 0F 5B /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTTPS2DQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.F3.0F.WIG 5B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert four packed single precision floatingpoint values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTTPS2DQ</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.F3.0F.WIG 5B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert eight packed single precision floatingpoint values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTTPS2PI--Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTTPS2PI</mnem>
			<args>mm,xmm/m64</args>
			<opc openc="RM">0F 2C /r</opc>
			<dscrp>Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTTSD2SI--Convert with Truncation Scalar Double-Precision FP Value to Signed Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTTSD2SI</mnem>
			<args>r32,xmm/m64</args>
			<opc openc="RM">F2 0F 2C /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CVTTSD2SI</mnem>
			<args>r64,xmm/m64</args>
			<opc openc="RM">F2 REX.W 0F 2C /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTTSD2SI</mnem>
			<args>r32,xmm1/m64</args>
			<opc openc="RM">VEX.LIG.F2.0F.W0 2C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.</dscrp>
		</ins>
		<ins x32m="NE1" x64m="V">
			<mnem>VCVTTSD2SI</mnem>
			<args>r64,xmm1/m64</args>
			<opc openc="RM">VEX.LIG.F2.0F.W1 2C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CVTTSS2SI--Convert with Truncation Scalar Single-Precision FP Value to Dword Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CVTTSS2SI</mnem>
			<args>r32,xmm/m32</args>
			<opc openc="RM">F3 0F 2C /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CVTTSS2SI</mnem>
			<args>r64,xmm/m32</args>
			<opc openc="RM">F3 REX.W 0F 2C /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTTSS2SI</mnem>
			<args>r32,xmm1/m32</args>
			<opc openc="RM">VEX.LIG.F3.0F.W0 2C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.</dscrp>
		</ins>
		<ins x32m="NE1" x64m="V">
			<mnem>VCVTTSS2SI</mnem>
			<args>r64,xmm1/m32</args>
			<opc openc="RM">VEX.LIG.F3.0F.W1 2C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>CWD/CDQ/CQO--Convert Word to Doubleword/Convert Doubleword to Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>CWD</mnem>
			<args>void</args>
			<opc openc="NP">99</opc>
			<dscrp>DX:AX &lt;-- sign-extend of AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>CDQ</mnem>
			<args>void</args>
			<opc openc="NP">99</opc>
			<dscrp>EDX:EAX &lt;-- sign-extend of EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>CQO</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + 99</opc>
			<dscrp>RDX:RAX&lt;-- sign-extend of RAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DAA--Decimal Adjust AL after Addition.</brief>
		<ins x32m="V" x64m="I">
			<mnem>DAA</mnem>
			<args>void</args>
			<opc openc="NP">27</opc>
			<dscrp>Decimal adjust AL after addition.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DAS--Decimal Adjust AL after Subtraction.</brief>
		<ins x32m="V" x64m="I">
			<mnem>DAS</mnem>
			<args>void</args>
			<opc openc="NP">2F</opc>
			<dscrp>Decimal adjust AL after subtraction.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DEC--Decrement by 1.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DEC</mnem>
			<args>r/m8*</args>
			<opc openc="M">FE /1</opc>
			<dscrp>Decrement r/m8 by 1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>DEC</mnem>
			<args>r/m8</args>
			<opc openc="M">REX + FE /1</opc>
			<dscrp>Decrement r/m8 by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>DEC</mnem>
			<args>r/m16</args>
			<opc openc="M">FF /1</opc>
			<dscrp>Decrement r/m16 by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>DEC</mnem>
			<args>r/m32</args>
			<opc openc="M">FF /1</opc>
			<dscrp>Decrement r/m32 by 1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>DEC</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + FF /1</opc>
			<dscrp>Decrement r/m64 by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>DEC</mnem>
			<args>r16</args>
			<opc openc="O">48+rw</opc>
			<dscrp>Decrement r16 by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>DEC</mnem>
			<args>r32</args>
			<opc openc="O">48+rd</opc>
			<dscrp>Decrement r32 by 1.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="O">
			<oprnd1>opcode + rd(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DIV--Unsigned Divide.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DIV</mnem>
			<args>r/m8*</args>
			<opc openc="M">F6 /6</opc>
			<dscrp>Unsigned divide AX by r/m8, with result stored in AL &lt;-- Quotient, AH ? Remainder.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>DIV</mnem>
			<args>r/m8</args>
			<opc openc="M">REX + F6 /6</opc>
			<dscrp>Unsigned divide AX by r/m8, with result stored in AL &lt;-- Quotient, AH ? Remainder.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>DIV</mnem>
			<args>r/m16</args>
			<opc openc="M">F7 /6</opc>
			<dscrp>Unsigned divide DX:AX by r/m16, with result stored in AX &lt;-- Quotient, DX ? Remainder.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>DIV</mnem>
			<args>r/m32</args>
			<opc openc="M">F7 /6</opc>
			<dscrp>Unsigned divide EDX:EAX by r/m32, with result stored in EAX &lt;-- Quotient, EDX ? Remainder.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>DIV</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + F7 /6</opc>
			<dscrp>Unsigned divide RDX:RAX by r/m64, with result stored in RAX &lt;-- Quotient, RDX ? Remainder.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DIVPD--Divide Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DIVPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 5E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDIVPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 5E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDIVPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 5E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DIVPS--Divide Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DIVPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 5E /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDIVPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 5E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Divide packed single-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDIVPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 5E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Divide packed single-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DIVSD--Divide Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DIVSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 5E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDIVSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 5E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Divide low double-precision floating point values in xmm2 by low double precision floating-point value in xmm3/mem64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DIVSS--Divide Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DIVSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 5E /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDIVSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 5E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Divide low single-precision floating point value in xmm2 by low single precision floating-point value in xmm3/m32.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DPPD--Dot Product of Packed Double Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DPPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 41 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Selectively multiply packed DP floating-point values from xmm1 with packed DP floatingpoint values from xmm2, add and selectively store the packed DP floating-point values to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDPPD</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 41 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Selectively multiply packed DP floating-point values from xmm2 with packed DP floatingpoint values from xmm3, add and selectively store the packed DP floating-point values to xmm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>DPPS--Dot Product of Packed Single Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>DPPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 40 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Selectively multiply packed SP floating-point values from xmm1 with packed SP floatingpoint values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDPPS</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 40 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VDPPS</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.WIG 40 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>EMMS--Empty MMX Technology State.</brief>
		<ins x32m="V" x64m="V">
			<mnem>EMMS</mnem>
			<args>void</args>
			<opc openc="NP">0F 77</opc>
			<dscrp>Set the x87 FPU tag word to empty.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ENTER--Make Stack Frame for Procedure Parameters.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ENTER</mnem>
			<args>imm16,0</args>
			<opc openc="II">C8 iw 00</opc>
			<dscrp>Create a stack frame for a procedure.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ENTER</mnem>
			<args>imm16,1</args>
			<opc openc="II">C8 iw 01</opc>
			<dscrp>Create a stack frame with a nested pointer for a procedure.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ENTER</mnem>
			<args>imm16,imm8</args>
			<opc openc="II">C8 iw ib</opc>
			<dscrp>Create a stack frame with nested pointers for a procedure.</dscrp>
		</ins>
		<oprndenc openc="II">
			<oprnd1>iw</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>EXTRACTPS--Extract Packed Single Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>EXTRACTPS</mnem>
			<args>reg/m32,xmm2,imm8</args>
			<opc openc="MRI">66 0F 3A 17 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VEXTRACTPS</mnem>
			<args>r/m32,xmm1,imm8</args>
			<opc openc="MRI">VEX.128.66.0F3A.WIG 17 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable.</dscrp>
		</ins>
		<oprndenc openc="MRI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>F2XM1--Compute 2  -1.</brief>
		<ins x32m="V" x64m="V">
			<mnem>F2XM1</mnem>
			<args>void</args>
			<opc openc="">D9 F0</opc>
			<dscrp>Replace ST(0) with (2ST(0) 1).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FABS--Absolute Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FABS</mnem>
			<args>void</args>
			<opc openc="">D9 E1</opc>
			<dscrp>Replace ST with its absolute value.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FADD/FADDP/FIADD--Add.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FADD</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /0</opc>
			<dscrp>Add m32fp to ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FADD</mnem>
			<args>m64fp</args>
			<opc openc="">DC /0</opc>
			<dscrp>Add m64fp to ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FADD</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">D8 C0+i</opc>
			<dscrp>Add ST(0) to ST(i) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FADD</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DC C0+i</opc>
			<dscrp>Add ST(i) to ST(0) and store result in ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FADDP</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DE C0+i</opc>
			<dscrp>Add ST(0) to ST(i), store result in ST(i), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FADDP</mnem>
			<args>void</args>
			<opc openc="">DE C1</opc>
			<dscrp>Add ST(0) to ST(1), store result in ST(1), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIADD</mnem>
			<args>m32int</args>
			<opc openc="">DA /0</opc>
			<dscrp>Add m32int to ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIADD</mnem>
			<args>m16int</args>
			<opc openc="">DE /0</opc>
			<dscrp>Add m16int to ST(0) and store result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FBLD--Load Binary Coded Decimal.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FBLD</mnem>
			<args>m80dec</args>
			<opc openc="">DF /4</opc>
			<dscrp>Convert BCD value to floating-point and push onto the FPU stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FBSTP--Store BCD Integer and Pop.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FBSTP</mnem>
			<args>m80bcd</args>
			<opc openc="">DF /6</opc>
			<dscrp>Store ST(0) in m80bcd and pop ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FCHS--Change Sign.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FCHS</mnem>
			<args>void</args>
			<opc openc="">D9 E0</opc>
			<dscrp>Complements sign of ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FCLEX/FNCLEX--Clear Exceptions.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FCLEX*</mnem>
			<args>void</args>
			<opc openc="">9B DB E2</opc>
			<dscrp>Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNCLEX</mnem>
			<args>void</args>
			<opc openc="">DB E2</opc>
			<dscrp>Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FCMOVcc--Floating-Point Conditional Move.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVB</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DA C0+i</opc>
			<dscrp>Move if below (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVE</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DA C8+i</opc>
			<dscrp>Move if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVBE</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DA D0+i</opc>
			<dscrp>Move if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVU</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DA D8+i</opc>
			<dscrp>Move if unordered (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVNB</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DB C0+i</opc>
			<dscrp>Move if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVNE</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DB C8+i</opc>
			<dscrp>Move if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVNBE</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DB D0+i</opc>
			<dscrp>Move if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCMOVNU</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">DB D8+i</opc>
			<dscrp>Move if not unordered (PF=0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FCOM/FCOMP/FCOMPP--Compare Floating Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FCOM</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /2</opc>
			<dscrp>Compare ST(0) with m32fp.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOM</mnem>
			<args>m64fp</args>
			<opc openc="">DC /2</opc>
			<dscrp>Compare ST(0) with m64fp.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOM</mnem>
			<args>ST(i)</args>
			<opc openc="">D8 D0+i</opc>
			<dscrp>Compare ST(0) with ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOM</mnem>
			<args>void</args>
			<opc openc="">D8 D1</opc>
			<dscrp>Compare ST(0) with ST(1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMP</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /3</opc>
			<dscrp>Compare ST(0) with m32fp and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMP</mnem>
			<args>m64fp</args>
			<opc openc="">DC /3</opc>
			<dscrp>Compare ST(0) with m64fp and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMP</mnem>
			<args>ST(i)</args>
			<opc openc="">D8 D8+i</opc>
			<dscrp>Compare ST(0) with ST(i) and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMP</mnem>
			<args>void</args>
			<opc openc="">D8 D9</opc>
			<dscrp>Compare ST(0) with ST(1) and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMPP</mnem>
			<args>void</args>
			<opc openc="">DE D9</opc>
			<dscrp>Compare ST(0) with ST(1) and pop register stack twice.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMI</mnem>
			<args>ST,ST(i)</args>
			<opc openc="">DB F0+i</opc>
			<dscrp>Compare ST(0) with ST(i) and set status flags accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FCOMIP</mnem>
			<args>ST,ST(i)</args>
			<opc openc="">DF F0+i</opc>
			<dscrp>Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FUCOMI</mnem>
			<args>ST,ST(i)</args>
			<opc openc="">DB E8+i</opc>
			<dscrp>Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FUCOMIP</mnem>
			<args>ST,ST(i)</args>
			<opc openc="">DF E8+i</opc>
			<dscrp>Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FCOS--Cosine.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FCOS</mnem>
			<args>void</args>
			<opc openc="">D9 FF</opc>
			<dscrp>Replace ST(0) with its approximate cosine.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FDECSTP--Decrement Stack-Top Pointer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FDECSTP</mnem>
			<args>void</args>
			<opc openc="">D9 F6</opc>
			<dscrp>Decrement TOP field in FPU status word.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FDIV/FDIVP/FIDIV--Divide.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FDIV</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /6</opc>
			<dscrp>Divide ST(0) by m32fp and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIV</mnem>
			<args>m64fp</args>
			<opc openc="">DC /6</opc>
			<dscrp>Divide ST(0) by m64fp and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIV</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">D8 F0+i</opc>
			<dscrp>Divide ST(0) by ST(i) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIV</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DC F8+i</opc>
			<dscrp>Divide ST(i) by ST(0) and store result in ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVP</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DE F8+i</opc>
			<dscrp>Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVP</mnem>
			<args>void</args>
			<opc openc="">DE F9</opc>
			<dscrp>Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIDIV</mnem>
			<args>m32int</args>
			<opc openc="">DA /6</opc>
			<dscrp>Divide ST(0) by m32int and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIDIV</mnem>
			<args>m16int</args>
			<opc openc="">DE /6</opc>
			<dscrp>Divide ST(0) by m16int and store result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FDIVR/FDIVRP/FIDIVR--Reverse Divide.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FDIVR</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /7</opc>
			<dscrp>Divide m32fp by ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVR</mnem>
			<args>m64fp</args>
			<opc openc="">DC /7</opc>
			<dscrp>Divide m64fp by ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVR</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">D8 F8+i</opc>
			<dscrp>Divide ST(i) by ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVR</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DC F0+i</opc>
			<dscrp>Divide ST(0) by ST(i) and store result in ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVRP</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DE F0+i</opc>
			<dscrp>Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FDIVRP</mnem>
			<args>void</args>
			<opc openc="">DE F1</opc>
			<dscrp>Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIDIVR</mnem>
			<args>m32int</args>
			<opc openc="">DA /7</opc>
			<dscrp>Divide m32int by ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIDIVR</mnem>
			<args>m16int</args>
			<opc openc="">DE /7</opc>
			<dscrp>Divide m16int by ST(0) and store result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FFREE--Free Floating-Point Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FFREE</mnem>
			<args>ST(i)</args>
			<opc openc="">DD C0+i</opc>
			<dscrp>Sets tag for ST(i) to empty.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FICOM/FICOMP--Compare Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FICOM</mnem>
			<args>m16int</args>
			<opc openc="">DE /2</opc>
			<dscrp>Compare ST(0) with m16int.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FICOM</mnem>
			<args>m32int</args>
			<opc openc="">DA /2</opc>
			<dscrp>Compare ST(0) with m32int.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FICOMP</mnem>
			<args>m16int</args>
			<opc openc="">DE /3</opc>
			<dscrp>Compare ST(0) with m16int and pop stack register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FICOMP</mnem>
			<args>m32int</args>
			<opc openc="">DA /3</opc>
			<dscrp>Compare ST(0) with m32int and pop stack register.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FILD--Load Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FILD</mnem>
			<args>m16int</args>
			<opc openc="">DF /0</opc>
			<dscrp>Push m16int onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FILD</mnem>
			<args>m32int</args>
			<opc openc="">DB /0</opc>
			<dscrp>Push m32int onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FILD</mnem>
			<args>m64int</args>
			<opc openc="">DF /5</opc>
			<dscrp>Push m64int onto the FPU register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FINCSTP--Increment Stack-Top Pointer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FINCSTP</mnem>
			<args>void</args>
			<opc openc="">D9 F7</opc>
			<dscrp>Increment the TOP field in the FPU status register.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FINIT/FNINIT--Initialize Floating-Point Unit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FINIT*</mnem>
			<args>void</args>
			<opc openc="">9B DB E3</opc>
			<dscrp>Initialize FPU after checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNINIT</mnem>
			<args>void</args>
			<opc openc="">DB E3</opc>
			<dscrp>Initialize FPU without checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FIST/FISTP--Store Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FIST</mnem>
			<args>m16int</args>
			<opc openc="">DF /2</opc>
			<dscrp>Store ST(0) in m16int.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIST</mnem>
			<args>m32int</args>
			<opc openc="">DB /2</opc>
			<dscrp>Store ST(0) in m32int.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISTP</mnem>
			<args>m16int</args>
			<opc openc="">DF /3</opc>
			<dscrp>Store ST(0) in m16int and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISTP</mnem>
			<args>m32int</args>
			<opc openc="">DB /3</opc>
			<dscrp>Store ST(0) in m32int and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISTP</mnem>
			<args>m64int</args>
			<opc openc="">DF /7</opc>
			<dscrp>Store ST(0) in m64int and pop register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FISTTP--Store Integer with Truncation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FISTTP</mnem>
			<args>m16int</args>
			<opc openc="">DF /1</opc>
			<dscrp>Store ST(0) in m16int with truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISTTP</mnem>
			<args>m32int</args>
			<opc openc="">DB /1</opc>
			<dscrp>Store ST(0) in m32int with truncation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISTTP</mnem>
			<args>m64int</args>
			<opc openc="">DD /1</opc>
			<dscrp>Store ST(0) in m64int with truncation.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FLD--Load Floating Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FLD</mnem>
			<args>m32fp</args>
			<opc openc="">D9 /0</opc>
			<dscrp>Push m32fp onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLD</mnem>
			<args>m64fp</args>
			<opc openc="">DD /0</opc>
			<dscrp>Push m64fp onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLD</mnem>
			<args>m80fp</args>
			<opc openc="">DB /5</opc>
			<dscrp>Push m80fp onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLD</mnem>
			<args>ST(i)</args>
			<opc openc="">D9 C0+i</opc>
			<dscrp>Push ST(i) onto the FPU register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ--Load Constant.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FLD1</mnem>
			<args>void</args>
			<opc openc="">D9 E8</opc>
			<dscrp>Push +1.0 onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLDL2T</mnem>
			<args>void</args>
			<opc openc="">D9 E9</opc>
			<dscrp>Push log210 onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLDL2E</mnem>
			<args>void</args>
			<opc openc="">D9 EA</opc>
			<dscrp>Push log2e onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLDPI</mnem>
			<args>void</args>
			<opc openc="">D9 EB</opc>
			<dscrp>Push p onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLDLG2</mnem>
			<args>void</args>
			<opc openc="">D9 EC</opc>
			<dscrp>Push log102 onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLDLN2</mnem>
			<args>void</args>
			<opc openc="">D9 ED</opc>
			<dscrp>Push loge2 onto the FPU register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FLDZ</mnem>
			<args>void</args>
			<opc openc="">D9 EE</opc>
			<dscrp>Push +0.0 onto the FPU register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FLDCW--Load x87 FPU Control Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FLDCW</mnem>
			<args>m2byte</args>
			<opc openc="">D9 /5</opc>
			<dscrp>Load FPU control word from m2byte.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FLDENV--Load x87 FPU Environment.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FLDENV</mnem>
			<args>m14/28byte</args>
			<opc openc="">D9 /4</opc>
			<dscrp>Load FPU environment from m14byte or m28byte.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FMUL/FMULP/FIMUL--Multiply.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FMUL</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /1</opc>
			<dscrp>Multiply ST(0) by m32fp and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FMUL</mnem>
			<args>m64fp</args>
			<opc openc="">DC /1</opc>
			<dscrp>Multiply ST(0) by m64fp and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FMUL</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">D8 C8+i</opc>
			<dscrp>Multiply ST(0) by ST(i) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FMUL</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DC C8+i</opc>
			<dscrp>Multiply ST(i) by ST(0) and store result in ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FMULP</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DE C8+i</opc>
			<dscrp>Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FMULP</mnem>
			<args>void</args>
			<opc openc="">DE C9</opc>
			<dscrp>Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIMUL</mnem>
			<args>m32int</args>
			<opc openc="">DA /1</opc>
			<dscrp>Multiply ST(0) by m32int and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FIMUL</mnem>
			<args>m16int</args>
			<opc openc="">DE /1</opc>
			<dscrp>Multiply ST(0) by m16int and store result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FNOP--No Operation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FNOP</mnem>
			<args>void</args>
			<opc openc="">D9 D0</opc>
			<dscrp>No operation is performed.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FPATAN--Partial Arctangent.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FPATAN</mnem>
			<args>void</args>
			<opc openc="">D9 F3</opc>
			<dscrp>Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FPREM--Partial Remainder.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FPREM</mnem>
			<args>void</args>
			<opc openc="">D9 F8</opc>
			<dscrp>Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FPREM1--Partial Remainder.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FPREM1</mnem>
			<args>void</args>
			<opc openc="">D9 F5</opc>
			<dscrp>Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FPTAN--Partial Tangent.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FPTAN</mnem>
			<args>void</args>
			<opc openc="">D9 F2</opc>
			<dscrp>Replace ST(0) with its approximate tangent and push 1 onto the FPU stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FRNDINT--Round to Integer.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FRNDINT</mnem>
			<args>void</args>
			<opc openc="">D9 FC</opc>
			<dscrp>Round ST(0) to an integer.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FRSTOR--Restore x87 FPU State.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FRSTOR</mnem>
			<args>m94/108byte</args>
			<opc openc="">DD /4</opc>
			<dscrp>Load FPU state from m94byte or m108byte.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSAVE/FNSAVE--Store x87 FPU State.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSAVE</mnem>
			<args>m94/108byte*</args>
			<opc openc="">9B DD /6</opc>
			<dscrp>Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNSAVE</mnem>
			<args>m94/108byte</args>
			<opc openc="">DD /6</opc>
			<dscrp>Store FPU environment to m94byte or m108byte without checking for pending unmasked floatingpoint exceptions. Then re-initialize the FPU.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSCALE--Scale.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSCALE</mnem>
			<args>void</args>
			<opc openc="">D9 FD</opc>
			<dscrp>Scale ST(0) by ST(1).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSIN--Sine.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSIN</mnem>
			<args>void</args>
			<opc openc="">D9 FE</opc>
			<dscrp>Replace ST(0) with the approximate of its sine.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSINCOS--Sine and Cosine.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSINCOS</mnem>
			<args>void</args>
			<opc openc="">D9 FB</opc>
			<dscrp>Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSQRT--Square Root.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSQRT</mnem>
			<args>void</args>
			<opc openc="">D9 FA</opc>
			<dscrp>Computes square root of ST(0) and stores the result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FST/FSTP--Store Floating Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FST</mnem>
			<args>m32fp</args>
			<opc openc="">D9 /2</opc>
			<dscrp>Copy ST(0) to m32fp.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FST</mnem>
			<args>m64fp</args>
			<opc openc="">DD /2</opc>
			<dscrp>Copy ST(0) to m64fp.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FST</mnem>
			<args>ST(i)</args>
			<opc openc="">DD D0+i</opc>
			<dscrp>Copy ST(0) to ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSTP</mnem>
			<args>m32fp</args>
			<opc openc="">D9 /3</opc>
			<dscrp>Copy ST(0) to m32fp and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSTP</mnem>
			<args>m64fp</args>
			<opc openc="">DD /3</opc>
			<dscrp>Copy ST(0) to m64fp and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSTP</mnem>
			<args>m80fp</args>
			<opc openc="">DB /7</opc>
			<dscrp>Copy ST(0) to m80fp and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSTP</mnem>
			<args>ST(i)</args>
			<opc openc="">DD D8+i</opc>
			<dscrp>Copy ST(0) to ST(i) and pop register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSTCW/FNSTCW--Store x87 FPU Control Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSTCW</mnem>
			<args>m2byte*</args>
			<opc openc="">9B D9 /7</opc>
			<dscrp>Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNSTCW</mnem>
			<args>m2byte</args>
			<opc openc="">D9 /7</opc>
			<dscrp>Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSTENV/FNSTENV--Store x87 FPU Environment.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSTENV</mnem>
			<args>m14/28byte*</args>
			<opc openc="">9B D9 /6</opc>
			<dscrp>Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNSTENV</mnem>
			<args>m14/28byte</args>
			<opc openc="">D9 /6</opc>
			<dscrp>Store FPU environment to m14byte or m28byte without checking for pending unmasked floatingpoint exceptions. Then mask all floatingpoint exceptions.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSTSW/FNSTSW--Store x87 FPU Status Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSTSW</mnem>
			<args>m2byte</args>
			<opc openc="">9B DD /7</opc>
			<dscrp>Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSTSW</mnem>
			<args>AX*</args>
			<opc openc="">9B DF E0</opc>
			<dscrp>Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNSTSW</mnem>
			<args>m2byte*</args>
			<opc openc="">DD /7</opc>
			<dscrp>Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FNSTSW</mnem>
			<args>AX</args>
			<opc openc="">DF E0</opc>
			<dscrp>Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSUB/FSUBP/FISUB--Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSUB</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /4</opc>
			<dscrp>Subtract m32fp from ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUB</mnem>
			<args>m64fp</args>
			<opc openc="">DC /4</opc>
			<dscrp>Subtract m64fp from ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUB</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">D8 E0+i</opc>
			<dscrp>Subtract ST(i) from ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUB</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DC E8+i</opc>
			<dscrp>Subtract ST(0) from ST(i) and store result in ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBP</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DE E8+i</opc>
			<dscrp>Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBP</mnem>
			<args>void</args>
			<opc openc="">DE E9</opc>
			<dscrp>Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISUB</mnem>
			<args>m32int</args>
			<opc openc="">DA /4</opc>
			<dscrp>Subtract m32int from ST(0) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISUB</mnem>
			<args>m16int</args>
			<opc openc="">DE /4</opc>
			<dscrp>Subtract m16int from ST(0) and store result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FSUBR/FSUBRP/FISUBR--Reverse Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FSUBR</mnem>
			<args>m32fp</args>
			<opc openc="">D8 /5</opc>
			<dscrp>Subtract ST(0) from m32fp and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBR</mnem>
			<args>m64fp</args>
			<opc openc="">DC /5</opc>
			<dscrp>Subtract ST(0) from m64fp and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBR</mnem>
			<args>ST(0),ST(i)</args>
			<opc openc="">D8 E8+i</opc>
			<dscrp>Subtract ST(0) from ST(i) and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBR</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DC E0+i</opc>
			<dscrp>Subtract ST(i) from ST(0) and store result in ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBRP</mnem>
			<args>ST(i),ST(0)</args>
			<opc openc="">DE E0+i</opc>
			<dscrp>Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FSUBRP</mnem>
			<args>void</args>
			<opc openc="">DE E1</opc>
			<dscrp>Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISUBR</mnem>
			<args>m32int</args>
			<opc openc="">DA /5</opc>
			<dscrp>Subtract ST(0) from m32int and store result in ST(0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FISUBR</mnem>
			<args>m16int</args>
			<opc openc="">DE /5</opc>
			<dscrp>Subtract ST(0) from m16int and store result in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FTST--TEST.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FTST</mnem>
			<args>void</args>
			<opc openc="">D9 E4</opc>
			<dscrp>Compare ST(0) with 0.0.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FUCOM/FUCOMP/FUCOMPP--Unordered Compare Floating Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FUCOM</mnem>
			<args>ST(i)</args>
			<opc openc="">DD E0+i</opc>
			<dscrp>Compare ST(0) with ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FUCOM</mnem>
			<args>void</args>
			<opc openc="">DD E1</opc>
			<dscrp>Compare ST(0) with ST(1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FUCOMP</mnem>
			<args>ST(i)</args>
			<opc openc="">DD E8+i</opc>
			<dscrp>Compare ST(0) with ST(i) and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FUCOMP</mnem>
			<args>void</args>
			<opc openc="">DD E9</opc>
			<dscrp>Compare ST(0) with ST(1) and pop register stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FUCOMPP</mnem>
			<args>void</args>
			<opc openc="">DA E9</opc>
			<dscrp>Compare ST(0) with ST(1) and pop register stack twice.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FXAM--Examine ModR/M.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FXAM</mnem>
			<args>void</args>
			<opc openc="">D9 E5</opc>
			<dscrp>Classify value or number in ST(0).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FXCH--Exchange Register Contents.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FXCH</mnem>
			<args>ST(i)</args>
			<opc openc="">D9 C8+i</opc>
			<dscrp>Exchange the contents of ST(0) and ST(i).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FXCH</mnem>
			<args>void</args>
			<opc openc="">D9 C9</opc>
			<dscrp>Exchange the contents of ST(0) and ST(1).</dscrp>
		</ins>
	</common>
	<common>
		<brief>FXRSTOR--Restore x87 FPU, MMX, XMM, and MXCSR State.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FXRSTOR</mnem>
			<args>m512byte</args>
			<opc openc="M">0F AE /1</opc>
			<dscrp>Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>FXRSTOR64</mnem>
			<args>m512byte</args>
			<opc openc="M">REX.W+ 0F AE /1</opc>
			<dscrp>Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>FXSAVE--Save x87 FPU, MMX Technology, and SSE State.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FXSAVE</mnem>
			<args>m512byte</args>
			<opc openc="M">0F AE /0</opc>
			<dscrp>Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>FXSAVE64</mnem>
			<args>m512byte</args>
			<opc openc="M">REX.W+ 0F AE /0</opc>
			<dscrp>Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>FXTRACT--Extract Exponent and Significand.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FXTRACT</mnem>
			<args>void</args>
			<opc openc="">D9 F4</opc>
			<dscrp>Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FYL2X--Compute y * log  x 2.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FYL2X</mnem>
			<args>void</args>
			<opc openc="">D9 F1</opc>
			<dscrp>Replace ST(1) with (ST(1) * log2ST(0)) and pop the register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>FYL2XP1--Compute y * log  (x + 1) 2.</brief>
		<ins x32m="V" x64m="V">
			<mnem>FYL2XP1</mnem>
			<args>void</args>
			<opc openc="">D9 F9</opc>
			<dscrp>Replace ST(1) with ST(1) * log2(ST(0) + 1.0) and pop the register stack.</dscrp>
		</ins>
	</common>
	<common>
		<brief>HADDPD--Packed Double-FP Horizontal Add.</brief>
		<ins x32m="V" x64m="V">
			<mnem>HADDPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 7C /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHADDPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 7C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHADDPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 7C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>HADDPS--Packed Single-FP Horizontal Add.</brief>
		<ins x32m="V" x64m="V">
			<mnem>HADDPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F2 0F 7C /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHADDPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.F2.0F.WIG 7C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHADDPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.F2.0F.WIG 7C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>HLT--Halt.</brief>
		<ins x32m="V" x64m="V">
			<mnem>HLT</mnem>
			<args>void</args>
			<opc openc="NP">F4</opc>
			<dscrp>Halt.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>HSUBPD--Packed Double-FP Horizontal Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>HSUBPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 7D /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHSUBPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 7D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHSUBPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 7D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>HSUBPS--Packed Single-FP Horizontal Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>HSUBPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F2 0F 7D /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHSUBPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.F2.0F.WIG 7D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VHSUBPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.F2.0F.WIG 7D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>IDIV--Signed Divide.</brief>
		<ins x32m="V" x64m="V">
			<mnem>IDIV</mnem>
			<args>r/m8</args>
			<opc openc="M">F6 /7</opc>
			<dscrp>Signed divide AX by r/m8, with result stored in: AL &lt;-- Quotient, AH ? Remainder.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IDIV</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + F6 /7</opc>
			<dscrp>Signed divide AX by r/m8, with result stored in AL &lt;-- Quotient, AH ? Remainder.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IDIV</mnem>
			<args>r/m16</args>
			<opc openc="M">F7 /7</opc>
			<dscrp>Signed divide DX:AX by r/m16, with result stored in AX &lt;-- Quotient, DX ? Remainder.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IDIV</mnem>
			<args>r/m32</args>
			<opc openc="M">F7 /7</opc>
			<dscrp>Signed divide EDX:EAX by r/m32, with result stored in EAX &lt;-- Quotient, EDX ? Remainder.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IDIV</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + F7 /7</opc>
			<dscrp>Signed divide RDX:RAX by r/m64, with result stored in RAX &lt;-- Quotient, RDX ? Remainder.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>IMUL--Signed Multiply.</brief>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r/m8*</args>
			<opc openc="M">F6 /5</opc>
			<dscrp>AX&lt;-- AL * r/m byte.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r/m16</args>
			<opc openc="M">F7 /5</opc>
			<dscrp>DX:AX &lt;-- AX * r/m word.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r/m32</args>
			<opc openc="M">F7 /5</opc>
			<dscrp>EDX:EAX &lt;-- EAX * r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IMUL</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + F7 /5</opc>
			<dscrp>RDX:RAX &lt;-- RAX * r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0F AF /r</opc>
			<dscrp>word register &lt;-- word register * r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0F AF /r</opc>
			<dscrp>doubleword register &lt;-- doubleword register * r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IMUL</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0F AF /r</opc>
			<dscrp>Quadword register &lt;-- Quadword register * r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r16,r/m16,imm8</args>
			<opc openc="RMI">6B /r ib</opc>
			<dscrp>word register &lt;-- r/m16 * sign-extended immediate byte.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r32,r/m32,imm8</args>
			<opc openc="RMI">6B /r ib</opc>
			<dscrp>doubleword register &lt;-- r/m32 * signextended immediate byte.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IMUL</mnem>
			<args>r64,r/m64,imm8</args>
			<opc openc="RMI">REX.W + 6B /r ib</opc>
			<dscrp>Quadword register &lt;-- r/m64 * sign-extended immediate byte.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r16,r/m16,imm16</args>
			<opc openc="RMI">69 /r iw</opc>
			<dscrp>word register &lt;-- r/m16 * immediate word.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IMUL</mnem>
			<args>r32,r/m32,imm32</args>
			<opc openc="RMI">69 /r id</opc>
			<dscrp>doubleword register &lt;-- r/m32 * immediate doubleword.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IMUL</mnem>
			<args>r64,r/m64,imm32</args>
			<opc openc="RMI">REX.W + 69 /r id</opc>
			<dscrp>Quadword register &lt;-- r/m64 * immediate doubleword.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)/16/32</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>IN--Input from Port.</brief>
		<ins x32m="V" x64m="V">
			<mnem>IN</mnem>
			<args>AL,imm8</args>
			<opc openc="I">E4 ib</opc>
			<dscrp>Input byte from imm8 I/O port address into AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IN</mnem>
			<args>AX,imm8</args>
			<opc openc="I">E5 ib</opc>
			<dscrp>Input word from imm8 I/O port address into AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IN</mnem>
			<args>EAX,imm8</args>
			<opc openc="I">E5 ib</opc>
			<dscrp>Input dword from imm8 I/O port address into EAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IN</mnem>
			<args>AL,DX</args>
			<opc openc="NP">EC</opc>
			<dscrp>Input byte from I/O port in DX into AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IN</mnem>
			<args>AX,DX</args>
			<opc openc="NP">ED</opc>
			<dscrp>Input word from I/O port in DX into AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IN</mnem>
			<args>EAX,DX</args>
			<opc openc="NP">ED</opc>
			<dscrp>Input doubleword from I/O port in DX into EAX.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>imm8(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INC--Increment by 1.</brief>
		<ins x32m="V" x64m="V">
			<mnem>INC</mnem>
			<args>r/m8*</args>
			<opc openc="M">FE /0</opc>
			<dscrp>Increment r/m byte by 1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>INC</mnem>
			<args>r/m8</args>
			<opc openc="M">REX + FE /0</opc>
			<dscrp>Increment r/m byte by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INC</mnem>
			<args>r/m16</args>
			<opc openc="M">FF /0</opc>
			<dscrp>Increment r/m word by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INC</mnem>
			<args>r/m32</args>
			<opc openc="M">FF /0</opc>
			<dscrp>Increment r/m doubleword by 1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>INC</mnem>
			<args>r/m64**</args>
			<opc openc="M">REX.W + FF /0</opc>
			<dscrp>Increment r/m quadword by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>INC</mnem>
			<args>r16</args>
			<opc openc="O">40+ rw</opc>
			<dscrp>Increment word register by 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>INC</mnem>
			<args>r32</args>
			<opc openc="O">40+ rd</opc>
			<dscrp>Increment doubleword register by 1.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="O">
			<oprnd1>opcode + rd(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INS/INSB/INSW/INSD--Input from Port to String.</brief>
		<ins x32m="V" x64m="V">
			<mnem>INS</mnem>
			<args>m8,DX</args>
			<opc openc="NP">6C</opc>
			<dscrp>Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INS</mnem>
			<args>m16,DX</args>
			<opc openc="NP">6D</opc>
			<dscrp>Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INS</mnem>
			<args>m32,DX</args>
			<opc openc="NP">6D</opc>
			<dscrp>Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INSB</mnem>
			<args>void</args>
			<opc openc="NP">6C</opc>
			<dscrp>Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INSW</mnem>
			<args>void</args>
			<opc openc="NP">6D</opc>
			<dscrp>Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INSD</mnem>
			<args>void</args>
			<opc openc="NP">6D</opc>
			<dscrp>Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INSERTPS--Insert Packed Single Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>INSERTPS</mnem>
			<args>xmm1,xmm2/m32,imm8</args>
			<opc openc="RMI">66 0F 3A 21 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VINSERTPS</mnem>
			<args>xmm1,xmm2,xmm3/m32,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 21 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Insert a single precision floating point value selected by imm8 from xmm3/m32 and merge into xmm2 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INTn/INTO/INT3--Call to Interrupt Procedure.</brief>
		<ins x32m="V" x64m="V">
			<mnem>INT</mnem>
			<args>3</args>
			<opc openc="NP">CC</opc>
			<dscrp>Interrupt 3--trap to debugger.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>INT</mnem>
			<args>imm8</args>
			<opc openc="I">CD ib</opc>
			<dscrp>Interrupt vector specified by immediate byte.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>INTO</mnem>
			<args>void</args>
			<opc openc="NP">CE</opc>
			<dscrp>Interrupt 4--if overflow flag is 1.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>imm8(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INVD--Invalidate Internal Caches.</brief>
		<ins x32m="V" x64m="V">
			<mnem>INVD</mnem>
			<args>void</args>
			<opc openc="NP">0F 08</opc>
			<dscrp>Flush internal caches; initiate flushing of external caches.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INVLPG--Invalidate TLB Entries.</brief>
		<ins x32m="V" x64m="V">
			<mnem>INVLPG</mnem>
			<args>m</args>
			<opc openc="M">0F 01/7</opc>
			<dscrp>Invalidate TLB entries for page containing m.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>INVPCID--Invalidate Process-Context Identifier.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>INVPCID</mnem>
			<args>r32,m128</args>
			<opc openc="RM">66 0F 38 82 /r</opc>
			<cpuid>
				<flag>INVPCID</flag>
			</cpuid>
			<dscrp>Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>INVPCID</mnem>
			<args>r64,m128</args>
			<opc openc="RM">66 0F 38 82 /r</opc>
			<cpuid>
				<flag>INVPCID</flag>
			</cpuid>
			<dscrp>Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(R)</oprnd1>
			<oprnd2>ModRM:r/m(R)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>IRET/IRETD--Interrupt Return.</brief>
		<ins x32m="V" x64m="V">
			<mnem>IRET</mnem>
			<args>void</args>
			<opc openc="NP">CF</opc>
			<dscrp>Interrupt return (16-bit operand size).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>IRETD</mnem>
			<args>void</args>
			<opc openc="NP">CF</opc>
			<dscrp>Interrupt return (32-bit operand size).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>IRETQ</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + CF</opc>
			<dscrp>Interrupt return (64-bit operand size).</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>Jcc--Jump if Condition Is Met.</brief>
		<ins x32m="V" x64m="V">
			<mnem>JA</mnem>
			<args>rel8</args>
			<opc openc="D">77 cb</opc>
			<dscrp>Jump short if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JAE</mnem>
			<args>rel8</args>
			<opc openc="D">73 cb</opc>
			<dscrp>Jump short if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JB</mnem>
			<args>rel8</args>
			<opc openc="D">72 cb</opc>
			<dscrp>Jump short if below (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JBE</mnem>
			<args>rel8</args>
			<opc openc="D">76 cb</opc>
			<dscrp>Jump short if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JC</mnem>
			<args>rel8</args>
			<opc openc="D">72 cb</opc>
			<dscrp>Jump short if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>JCXZ</mnem>
			<args>rel8</args>
			<opc openc="D">E3 cb</opc>
			<dscrp>Jump short if CX register is 0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JECXZ</mnem>
			<args>rel8</args>
			<opc openc="D">E3 cb</opc>
			<dscrp>Jump short if ECX register is 0.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>JRCXZ</mnem>
			<args>rel8</args>
			<opc openc="D">E3 cb</opc>
			<dscrp>Jump short if RCX register is 0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JE</mnem>
			<args>rel8</args>
			<opc openc="D">74 cb</opc>
			<dscrp>Jump short if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JG</mnem>
			<args>rel8</args>
			<opc openc="D">7F cb</opc>
			<dscrp>Jump short if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JGE</mnem>
			<args>rel8</args>
			<opc openc="D">7D cb</opc>
			<dscrp>Jump short if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JL</mnem>
			<args>rel8</args>
			<opc openc="D">7C cb</opc>
			<dscrp>Jump short if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JLE</mnem>
			<args>rel8</args>
			<opc openc="D">7E cb</opc>
			<dscrp>Jump short if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNA</mnem>
			<args>rel8</args>
			<opc openc="D">76 cb</opc>
			<dscrp>Jump short if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNAE</mnem>
			<args>rel8</args>
			<opc openc="D">72 cb</opc>
			<dscrp>Jump short if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNB</mnem>
			<args>rel8</args>
			<opc openc="D">73 cb</opc>
			<dscrp>Jump short if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNBE</mnem>
			<args>rel8</args>
			<opc openc="D">77 cb</opc>
			<dscrp>Jump short if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNC</mnem>
			<args>rel8</args>
			<opc openc="D">73 cb</opc>
			<dscrp>Jump short if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNE</mnem>
			<args>rel8</args>
			<opc openc="D">75 cb</opc>
			<dscrp>Jump short if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNG</mnem>
			<args>rel8</args>
			<opc openc="D">7E cb</opc>
			<dscrp>Jump short if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNGE</mnem>
			<args>rel8</args>
			<opc openc="D">7C cb</opc>
			<dscrp>Jump short if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNL</mnem>
			<args>rel8</args>
			<opc openc="D">7D cb</opc>
			<dscrp>Jump short if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNLE</mnem>
			<args>rel8</args>
			<opc openc="D">7F cb</opc>
			<dscrp>Jump short if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNO</mnem>
			<args>rel8</args>
			<opc openc="D">71 cb</opc>
			<dscrp>Jump short if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNP</mnem>
			<args>rel8</args>
			<opc openc="D">7B cb</opc>
			<dscrp>Jump short if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNS</mnem>
			<args>rel8</args>
			<opc openc="D">79 cb</opc>
			<dscrp>Jump short if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNZ</mnem>
			<args>rel8</args>
			<opc openc="D">75 cb</opc>
			<dscrp>Jump short if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JO</mnem>
			<args>rel8</args>
			<opc openc="D">70 cb</opc>
			<dscrp>Jump short if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JP</mnem>
			<args>rel8</args>
			<opc openc="D">7A cb</opc>
			<dscrp>Jump short if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JPE</mnem>
			<args>rel8</args>
			<opc openc="D">7A cb</opc>
			<dscrp>Jump short if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JPO</mnem>
			<args>rel8</args>
			<opc openc="D">7B cb</opc>
			<dscrp>Jump short if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JS</mnem>
			<args>rel8</args>
			<opc openc="D">78 cb</opc>
			<dscrp>Jump short if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JZ</mnem>
			<args>rel8</args>
			<opc openc="D">74 cb</opc>
			<dscrp>Jump short if zero (ZF = 1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JA</mnem>
			<args>rel16</args>
			<opc openc="D">0F 87 cw</opc>
			<dscrp>Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JA</mnem>
			<args>rel32</args>
			<opc openc="D">0F 87 cd</opc>
			<dscrp>Jump near if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JAE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 83 cw</opc>
			<dscrp>Jump near if above or equal (CF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JAE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 83 cd</opc>
			<dscrp>Jump near if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JB</mnem>
			<args>rel16</args>
			<opc openc="D">0F 82 cw</opc>
			<dscrp>Jump near if below (CF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JB</mnem>
			<args>rel32</args>
			<opc openc="D">0F 82 cd</opc>
			<dscrp>Jump near if below (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JBE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 86 cw</opc>
			<dscrp>Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JBE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 86 cd</opc>
			<dscrp>Jump near if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JC</mnem>
			<args>rel16</args>
			<opc openc="D">0F 82 cw</opc>
			<dscrp>Jump near if carry (CF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JC</mnem>
			<args>rel32</args>
			<opc openc="D">0F 82 cd</opc>
			<dscrp>Jump near if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 84 cw</opc>
			<dscrp>Jump near if equal (ZF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 84 cd</opc>
			<dscrp>Jump near if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JZ</mnem>
			<args>rel16</args>
			<opc openc="D">0F 84 cw</opc>
			<dscrp>Jump near if 0 (ZF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JZ</mnem>
			<args>rel32</args>
			<opc openc="D">0F 84 cd</opc>
			<dscrp>Jump near if 0 (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JG</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8F cw</opc>
			<dscrp>Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JG</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8F cd</opc>
			<dscrp>Jump near if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JGE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8D cw</opc>
			<dscrp>Jump near if greater or equal (SF=OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JGE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8D cd</opc>
			<dscrp>Jump near if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JL</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8C cw</opc>
			<dscrp>Jump near if less (SF != OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JL</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8C cd</opc>
			<dscrp>Jump near if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JLE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8E cw</opc>
			<dscrp>Jump near if less or equal (ZF=1 or SF != OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JLE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8E cd</opc>
			<dscrp>Jump near if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNA</mnem>
			<args>rel16</args>
			<opc openc="D">0F 86 cw</opc>
			<dscrp>Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNA</mnem>
			<args>rel32</args>
			<opc openc="D">0F 86 cd</opc>
			<dscrp>Jump near if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNAE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 82 cw</opc>
			<dscrp>Jump near if not above or equal (CF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNAE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 82 cd</opc>
			<dscrp>Jump near if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNB</mnem>
			<args>rel16</args>
			<opc openc="D">0F 83 cw</opc>
			<dscrp>Jump near if not below (CF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNB</mnem>
			<args>rel32</args>
			<opc openc="D">0F 83 cd</opc>
			<dscrp>Jump near if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNBE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 87 cw</opc>
			<dscrp>Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNBE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 87 cd</opc>
			<dscrp>Jump near if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNC</mnem>
			<args>rel16</args>
			<opc openc="D">0F 83 cw</opc>
			<dscrp>Jump near if not carry (CF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNC</mnem>
			<args>rel32</args>
			<opc openc="D">0F 83 cd</opc>
			<dscrp>Jump near if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 85 cw</opc>
			<dscrp>Jump near if not equal (ZF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 85 cd</opc>
			<dscrp>Jump near if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNG</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8E cw</opc>
			<dscrp>Jump near if not greater (ZF=1 or SF != OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNG</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8E cd</opc>
			<dscrp>Jump near if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNGE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8C cw</opc>
			<dscrp>Jump near if not greater or equal (SF != OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNGE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8C cd</opc>
			<dscrp>Jump near if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNL</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8D cw</opc>
			<dscrp>Jump near if not less (SF=OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNL</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8D cd</opc>
			<dscrp>Jump near if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNLE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8F cw</opc>
			<dscrp>Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNLE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8F cd</opc>
			<dscrp>Jump near if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNO</mnem>
			<args>rel16</args>
			<opc openc="D">0F 81 cw</opc>
			<dscrp>Jump near if not overflow (OF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNO</mnem>
			<args>rel32</args>
			<opc openc="D">0F 81 cd</opc>
			<dscrp>Jump near if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNP</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8B cw</opc>
			<dscrp>Jump near if not parity (PF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNP</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8B cd</opc>
			<dscrp>Jump near if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNS</mnem>
			<args>rel16</args>
			<opc openc="D">0F 89 cw</opc>
			<dscrp>Jump near if not sign (SF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNS</mnem>
			<args>rel32</args>
			<opc openc="D">0F 89 cd</opc>
			<dscrp>Jump near if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JNZ</mnem>
			<args>rel16</args>
			<opc openc="D">0F 85 cw</opc>
			<dscrp>Jump near if not zero (ZF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JNZ</mnem>
			<args>rel32</args>
			<opc openc="D">0F 85 cd</opc>
			<dscrp>Jump near if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JO</mnem>
			<args>rel16</args>
			<opc openc="D">0F 80 cw</opc>
			<dscrp>Jump near if overflow (OF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JO</mnem>
			<args>rel32</args>
			<opc openc="D">0F 80 cd</opc>
			<dscrp>Jump near if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JP</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8A cw</opc>
			<dscrp>Jump near if parity (PF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JP</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8A cd</opc>
			<dscrp>Jump near if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JPE</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8A cw</opc>
			<dscrp>Jump near if parity even (PF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JPE</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8A cd</opc>
			<dscrp>Jump near if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JPO</mnem>
			<args>rel16</args>
			<opc openc="D">0F 8B cw</opc>
			<dscrp>Jump near if parity odd (PF=0). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JPO</mnem>
			<args>rel32</args>
			<opc openc="D">0F 8B cd</opc>
			<dscrp>Jump near if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JS</mnem>
			<args>rel16</args>
			<opc openc="D">0F 88 cw</opc>
			<dscrp>Jump near if sign (SF=1). Not supported in 64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JS</mnem>
			<args>rel32</args>
			<opc openc="D">0F 88 cd</opc>
			<dscrp>Jump near if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JZ</mnem>
			<args>rel16</args>
			<opc openc="D">0F 84 cw</opc>
			<dscrp>Jump near if 0 (ZF=1). Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JZ</mnem>
			<args>rel32</args>
			<opc openc="D">0F 84 cd</opc>
			<dscrp>Jump near if 0 (ZF=1).</dscrp>
		</ins>
		<oprndenc openc="D">
			<oprnd1>Offset</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>JMP--Jump.</brief>
		<ins x32m="V" x64m="V">
			<mnem>JMP</mnem>
			<args>rel8</args>
			<opc openc="D">EB cb</opc>
			<dscrp>Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JMP</mnem>
			<args>rel16</args>
			<opc openc="D">E9 cw</opc>
			<dscrp>Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JMP</mnem>
			<args>rel32</args>
			<opc openc="D">E9 cd</opc>
			<dscrp>Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JMP</mnem>
			<args>r/m16</args>
			<opc openc="M">FF /4</opc>
			<dscrp>Jump near, absolute indirect, address = zeroextended r/m16. Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="V" x64m="NS">
			<mnem>JMP</mnem>
			<args>r/m32</args>
			<opc openc="M">FF /4</opc>
			<dscrp>Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>JMP</mnem>
			<args>r/m64</args>
			<opc openc="M">FF /4</opc>
			<dscrp>Jump near, absolute indirect, RIP = 64-Bit offset from register or memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>JMP</mnem>
			<args>ptr16:16</args>
			<opc openc="D">EA cd</opc>
			<dscrp>Jump far, absolute, address given in operand.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>JMP</mnem>
			<args>ptr16:32</args>
			<opc openc="D">EA cp</opc>
			<dscrp>Jump far, absolute, address given in operand.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JMP</mnem>
			<args>m16:16</args>
			<opc openc="D">FF /5</opc>
			<dscrp>Jump far, absolute indirect, address given in m16:16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>JMP</mnem>
			<args>m16:32</args>
			<opc openc="D">FF /5</opc>
			<dscrp>Jump far, absolute indirect, address given in m16:32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>JMP</mnem>
			<args>m16:64</args>
			<opc openc="D">REX.W + FF /5</opc>
			<dscrp>Jump far, absolute indirect, address given in m16:64.</dscrp>
		</ins>
		<oprndenc openc="D">
			<oprnd1>Offset</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LAHF--Load Status Flags into AH Register.</brief>
		<ins x32m="V" x64m="I*">
			<mnem>LAHF</mnem>
			<args>void</args>
			<opc openc="NP">9F</opc>
			<dscrp>Load: AH &lt;-- EFLAGS(SF:ZF:0:AF:0:PF:1:CF).</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LAR--Load Access Rights Byte.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LAR</mnem>
			<args>r16,r16/m16</args>
			<opc openc="RM">0F 02 /r</opc>
			<dscrp>r16 &lt;-- access rights referenced by r16/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LAR</mnem>
			<args>reg,r32/m16 1</args>
			<opc openc="RM">0F 02 /r</opc>
			<dscrp>reg &lt;-- access rights referenced by r32/m16.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LDDQU--Load Unaligned Integer 128 Bits.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LDDQU</mnem>
			<args>xmm1,mem</args>
			<opc openc="RM">F2 0F F0 /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Load unaligned data from mem and return double quadword in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VLDDQU</mnem>
			<args>xmm1,m128</args>
			<opc openc="RM">VEX.128.F2.0F.WIG F0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Load unaligned packed integer values from mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VLDDQU</mnem>
			<args>ymm1,m256</args>
			<opc openc="RM">VEX.256.F2.0F.WIG F0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Load unaligned packed integer values from mem to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LDMXCSR--Load MXCSR Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LDMXCSR</mnem>
			<args>m32</args>
			<opc openc="M">0F,AE,/2</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Load MXCSR register from m32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VLDMXCSR</mnem>
			<args>m32</args>
			<opc openc="M">VEX.LZ.0F.WIG AE /2</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Load MXCSR register from m32.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LDS/LES/LFS/LGS/LSS--Load Far Pointer.</brief>
		<ins x32m="V" x64m="I">
			<mnem>LDS</mnem>
			<args>r16,m16:16</args>
			<opc openc="RM">C5 /r</opc>
			<dscrp>Load DS:r16 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>LDS</mnem>
			<args>r32,m16:32</args>
			<opc openc="RM">C5 /r</opc>
			<dscrp>Load DS:r32 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LSS</mnem>
			<args>r16,m16:16</args>
			<opc openc="RM">0F B2 /r</opc>
			<dscrp>Load SS:r16 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LSS</mnem>
			<args>r32,m16:32</args>
			<opc openc="RM">0F B2 /r</opc>
			<dscrp>Load SS:r32 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LSS</mnem>
			<args>r64,m16:64</args>
			<opc openc="RM">REX + 0F B2 /r</opc>
			<dscrp>Load SS:r64 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>LES</mnem>
			<args>r16,m16:16</args>
			<opc openc="RM">C4 /r</opc>
			<dscrp>Load ES:r16 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>LES</mnem>
			<args>r32,m16:32</args>
			<opc openc="RM">C4 /r</opc>
			<dscrp>Load ES:r32 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LFS</mnem>
			<args>r16,m16:16</args>
			<opc openc="RM">0F B4 /r</opc>
			<dscrp>Load FS:r16 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LFS</mnem>
			<args>r32,m16:32</args>
			<opc openc="RM">0F B4 /r</opc>
			<dscrp>Load FS:r32 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LFS</mnem>
			<args>r64,m16:64</args>
			<opc openc="RM">REX + 0F B4 /r</opc>
			<dscrp>Load FS:r64 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LGS</mnem>
			<args>r16,m16:16</args>
			<opc openc="RM">0F B5 /r</opc>
			<dscrp>Load GS:r16 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LGS</mnem>
			<args>r32,m16:32</args>
			<opc openc="RM">0F B5 /r</opc>
			<dscrp>Load GS:r32 with far pointer from memory.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LGS</mnem>
			<args>r64,m16:64</args>
			<opc openc="RM">REX + 0F B5 /r</opc>
			<dscrp>Load GS:r64 with far pointer from memory.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LEA--Load Effective Address.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LEA</mnem>
			<args>r16,m</args>
			<opc openc="RM">8D /r</opc>
			<dscrp>Store effective address for m in register r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LEA</mnem>
			<args>r32,m</args>
			<opc openc="RM">8D /r</opc>
			<dscrp>Store effective address for m in register r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LEA</mnem>
			<args>r64,m</args>
			<opc openc="RM">REX.W + 8D /r</opc>
			<dscrp>Store effective address for m in register r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LEAVE--High Level Procedure Exit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LEAVE</mnem>
			<args>void</args>
			<opc openc="NP">C9</opc>
			<dscrp>Set SP to BP, then pop BP.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>LEAVE</mnem>
			<args>void</args>
			<opc openc="NP">C9</opc>
			<dscrp>Set ESP to EBP, then pop EBP.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LEAVE</mnem>
			<args>void</args>
			<opc openc="NP">C9</opc>
			<dscrp>Set RSP to RBP, then pop RBP.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LFENCE--Load Fence.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LFENCE</mnem>
			<args>void</args>
			<opc openc="NP">0F AE E8</opc>
			<dscrp>Serializes load operations.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LGDT/LIDT--Load Global/Interrupt Descriptor Table Register.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>LGDT</mnem>
			<args>m16&amp;32</args>
			<opc openc="M">0F 01 /2</opc>
			<dscrp>Load m into GDTR.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>LIDT</mnem>
			<args>m16&amp;32</args>
			<opc openc="M">0F 01 /3</opc>
			<dscrp>Load m into IDTR.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LGDT</mnem>
			<args>m16&amp;64</args>
			<opc openc="M">0F 01 /2</opc>
			<dscrp>Load m into GDTR.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LIDT</mnem>
			<args>m16&amp;64</args>
			<opc openc="M">0F 01 /3</opc>
			<dscrp>Load m into IDTR.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LLDT--Load Local Descriptor Table Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LLDT</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 00 /2</opc>
			<dscrp>Load segment selector r/m16 into LDTR.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LMSW--Load Machine Status Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LMSW</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 01 /6</opc>
			<dscrp>Loads r/m 16 in machine status word of CR0.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LOCK--Assert LOCK# Signal Prefix.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LOCK</mnem>
			<args>void</args>
			<opc openc="NP">F0</opc>
			<cpuid>
				<flag>#Asserts LOCK</flag>
			</cpuid>
			<dscrp> signal for duration of the accompanying instruction.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LODS/LODSB/LODSW/LODSD/LODSQ--Load String.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LODS</mnem>
			<args>m8</args>
			<opc openc="NP">AC</opc>
			<dscrp>For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LODS</mnem>
			<args>m16</args>
			<opc openc="NP">AD</opc>
			<dscrp>For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LODS</mnem>
			<args>m32</args>
			<opc openc="NP">AD</opc>
			<dscrp>For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LODS</mnem>
			<args>m64</args>
			<opc openc="NP">REX.W + AD</opc>
			<dscrp>Load qword at address (R)SI into RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LODSB</mnem>
			<args>void</args>
			<opc openc="NP">AC</opc>
			<dscrp>For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LODSW</mnem>
			<args>void</args>
			<opc openc="NP">AD</opc>
			<dscrp>For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LODSD</mnem>
			<args>void</args>
			<opc openc="NP">AD</opc>
			<dscrp>For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LODSQ</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + AD</opc>
			<dscrp>Load qword at address (R)SI into RAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LOOP/LOOPcc--Loop According to ECX Counter.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LOOP</mnem>
			<args>rel8</args>
			<opc openc="D">E2 cb</opc>
			<dscrp>Decrement count; jump short if count != 0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LOOPE</mnem>
			<args>rel8</args>
			<opc openc="D">E1 cb</opc>
			<dscrp>Decrement count; jump short if count != 0 and ZF = 1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LOOPNE</mnem>
			<args>rel8</args>
			<opc openc="D">E0 cb</opc>
			<dscrp>Decrement count; jump short if count != 0 and ZF = 0.</dscrp>
		</ins>
		<oprndenc openc="D">
			<oprnd1>Offset</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LSL--Load Segment Limit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LSL</mnem>
			<args>r16,r16/m16*</args>
			<opc openc="RM">0F 03 /r</opc>
			<dscrp>Load: r16 &lt;-- segment limit, selector r16/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LSL</mnem>
			<args>r32,r32/m16*</args>
			<opc openc="RM">0F 03 /r</opc>
			<dscrp>Load: r32 &lt;-- segment limit, selector r32/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LSL</mnem>
			<args>r64,r32/m16</args>
			<opc openc="RM">REX.W + 0F 03 /r</opc>
			<dscrp>Load: r64 &lt;-- segment limit, selector r32/m16.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LTR--Load Task Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LTR</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 00 /3</opc>
			<dscrp>Load r/m16 into task register.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>LZCNT--Count the Number of Leading Zero Bits.</brief>
		<ins x32m="V" x64m="V">
			<mnem>LZCNT</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">F3 0F BD /r</opc>
			<cpuid>
				<flag>LZCNT</flag>
			</cpuid>
			<dscrp>Count the number of leading zero bits in r/m16, return result in r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>LZCNT</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">F3 0F BD /r</opc>
			<cpuid>
				<flag>LZCNT</flag>
			</cpuid>
			<dscrp>Count the number of leading zero bits in r/m32, return result in r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>LZCNT</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">F3 REX.W 0F BD /r</opc>
			<cpuid>
				<flag>LZCNT</flag>
			</cpuid>
			<dscrp>Count the number of leading zero bits in r/m64, return result in r64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MASKMOVDQU--Store Selected Bytes of Double Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MASKMOVDQU</mnem>
			<args>xmm1,xmm2</args>
			<opc openc="RM">66 0F F7 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVDQU</mnem>
			<args>xmm1,xmm2</args>
			<opc openc="RM">VEX.128.66.0F.WIG F7 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MASKMOVQ--Store Selected Bytes of Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MASKMOVQ</mnem>
			<args>mm1,mm2</args>
			<opc openc="RM">0F F7 /r</opc>
			<dscrp>Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MAXPD--Return Maximum Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MAXPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 5F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMAXPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 5F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the maximum double-precision floating-point values between xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMAXPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 5F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the maximum packed double-precision floating-point values between ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MAXPS--Return Maximum Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MAXPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 5F /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Return the maximum single-precision floatingpoint values between xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMAXPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 5F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the maximum single-precision floatingpoint values between xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMAXPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 5F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the maximum single double-precision floating-point values between ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MAXSD--Return Maximum Scalar Double-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MAXSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 5F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMAXSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 5F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the maximum scalar double-precision floating-point value between xmm3/mem64 and xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MAXSS--Return Maximum Scalar Single-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MAXSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 5F /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMAXSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 5F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the maximum scalar single-precision floating-point value between xmm3/mem32 and xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MFENCE--Memory Fence.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MFENCE</mnem>
			<args>void</args>
			<opc openc="NP">0F AE F0</opc>
			<dscrp>Serializes load and store operations.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MINPD--Return Minimum Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MINPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 5D /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMINPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 5D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the minimum double-precision floatingpoint values between xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMINPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 5D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MINPS--Return Minimum Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MINPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 5D /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Return the minimum single-precision floatingpoint values between xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMINPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 5D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the minimum single-precision floatingpoint values between xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMINPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 5D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MINSD--Return Minimum Scalar Double-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MINSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 5D /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMINSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 5D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the minimum scalar double precision floating-point value between xmm3/mem64 and xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MINSS--Return Minimum Scalar Single-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MINSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 5D /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMINSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 5D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the minimum scalar single precision floating-point value between xmm3/mem32 and xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MONITOR--Set Up Monitor Address.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MONITOR</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 C8</opc>
			<dscrp>Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a writeback memory caching type. The address is DS:EAX (DS:RAX in 64-bit mode).</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOV--Move.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">88 /r</opc>
			<dscrp>Move r8 to r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m8***,r8***</args>
			<opc openc="MR">REX + 88 /r</opc>
			<dscrp>Move r8 to r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">89 /r</opc>
			<dscrp>Move r16 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">89 /r</opc>
			<dscrp>Move r32 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 89 /r</opc>
			<dscrp>Move r64 to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">8A /r</opc>
			<dscrp>Move r/m8 to r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r8***,r/m8***</args>
			<opc openc="RM">REX + 8A /r</opc>
			<dscrp>Move r/m8 to r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">8B /r</opc>
			<dscrp>Move r/m16 to r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">8B /r</opc>
			<dscrp>Move r/m32 to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 8B /r</opc>
			<dscrp>Move r/m64 to r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m16,Sreg**</args>
			<opc openc="MR">8C /r</opc>
			<dscrp>Move segment register to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m64,Sreg**</args>
			<opc openc="MR">REX.W + 8C /r</opc>
			<dscrp>Move zero extended 16-bit segment register to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>Sreg,r/m16**</args>
			<opc openc="RM">8E /r</opc>
			<dscrp>Move r/m16 to segment register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>Sreg,r/m64**</args>
			<opc openc="RM">REX.W + 8E /r</opc>
			<dscrp>Move lower 16 bits of r/m64 to segment register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>AL,moffs8*</args>
			<opc openc="FD">A0</opc>
			<dscrp>Move byte at (seg:offset) to AL.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>AL,moffs8*</args>
			<opc openc="FD">REX.W + A0</opc>
			<dscrp>Move byte at (offset) to AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>AX,moffs16*</args>
			<opc openc="FD">A1</opc>
			<dscrp>Move word at (seg:offset) to AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>EAX,moffs32*</args>
			<opc openc="FD">A1</opc>
			<dscrp>Move doubleword at (seg:offset) to EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>RAX,moffs64*</args>
			<opc openc="FD">REX.W + A1</opc>
			<dscrp>Move quadword at (offset) to RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>moffs8,AL***</args>
			<opc openc="TD">A2</opc>
			<dscrp>Move AL to (seg:offset).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>moffs8,AL</args>
			<opc openc="TD">REX.W + A2</opc>
			<dscrp>Move AL to (offset).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>moffs16*,AX</args>
			<opc openc="TD">A3</opc>
			<dscrp>Move AX to (seg:offset).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>moffs32*,EAX</args>
			<opc openc="TD">A3</opc>
			<dscrp>Move EAX to (seg:offset).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>moffs64*,RAX</args>
			<opc openc="TD">REX.W + A3</opc>
			<dscrp>Move RAX to (offset).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r8,imm8***</args>
			<opc openc="OI">B0+ rb ib</opc>
			<dscrp>Move imm8 to r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r8,imm8</args>
			<opc openc="OI">REX + B0+ rb ib</opc>
			<dscrp>Move imm8 to r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r16,imm16</args>
			<opc openc="OI">B8+ rw iw</opc>
			<dscrp>Move imm16 to r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r32,imm32</args>
			<opc openc="OI">B8+ rd id</opc>
			<dscrp>Move imm32 to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r64,imm64</args>
			<opc openc="OI">REX.W + B8+ rd io</opc>
			<dscrp>Move imm64 to r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C6 /0 ib</opc>
			<dscrp>Move imm8 to r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m8***,imm8</args>
			<opc openc="MI">REX + C6 /0 ib</opc>
			<dscrp>Move imm8 to r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">C7 /0 iw</opc>
			<dscrp>Move imm16 to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">C7 /0 id</opc>
			<dscrp>Move imm32 to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + C7 /0 io</opc>
			<dscrp>Move imm32 sign extended to 64-bits to r/m64.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="FD">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>Moffs</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="TD">
			<oprnd1>Moffs(w)</oprnd1>
			<oprnd2>AL/AX/EAX/RAX</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="OI">
			<oprnd1>opcode + rd(w)</oprnd1>
			<oprnd2>imm8(r)/16/32/64</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>imm8(r)/16/32/64</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOV--Move to/from Control Registers.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>MOV</mnem>
			<args>r32,CR0-CR7</args>
			<opc openc="MR">0F 20/r</opc>
			<dscrp>Move control register to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r64,CR0-CR7</args>
			<opc openc="MR">0F 20/r</opc>
			<dscrp>Move extended control register to r64. 1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r64,CR8</args>
			<opc openc="MR">REX.R + 0F 20 /0</opc>
			<dscrp>Move extended CR8 to r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>MOV</mnem>
			<args>CR0-CR7,r32</args>
			<opc openc="RM">0F 22 /r</opc>
			<dscrp>Move r32 to control register.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>CR0-CR7,r64</args>
			<opc openc="RM">0F 22 /r</opc>
			<dscrp>Move r64 to extended control register. 1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>CR8,r64</args>
			<opc openc="RM">REX.R + 0F 22 /0</opc>
			<dscrp>Move r64 to extended CR8.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOV--Move to/from Debug Registers.</brief>
		<ins x32m="V" x64m="NE">
			<mnem>MOV</mnem>
			<args>r32,DR0-DR7</args>
			<opc openc="MR">0F 21/r</opc>
			<dscrp>Move debug register to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>r64,DR0-DR7</args>
			<opc openc="MR">0F 21/r</opc>
			<dscrp>Move extended debug register to r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>MOV</mnem>
			<args>DR0-DR7,r32</args>
			<opc openc="RM">0F 23 /r</opc>
			<dscrp>Move r32 to debug register.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOV</mnem>
			<args>DR0-DR7,r64</args>
			<opc openc="RM">0F 23 /r</opc>
			<dscrp>Move r64 to extended debug register.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVAPD--Move Aligned Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVAPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 28 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move packed double-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVAPD</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">66 0F 29 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move packed double-precision floating-point values from xmm1 to xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG 28 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed double-precision floatingpoint values from xmm2/mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPD</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG 29 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed double-precision floatingpoint values from xmm1 to xmm2/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPD</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG 28 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed double-precision floatingpoint values from ymm2/mem to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPD</mnem>
			<args>ymm2/m256,ymm1</args>
			<opc openc="MR">VEX.256.66.0F.WIG 29 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed double-precision floatingpoint values from ymm1 to ymm2/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVAPS--Move Aligned Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVAPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 28 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move packed single-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVAPS</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">0F 29 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move packed single-precision floating-point values from xmm1 to xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.0F.WIG 28 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed single-precision floatingpoint values from xmm2/mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPS</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">VEX.128.0F.WIG 29 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed single-precision floatingpoint values from xmm1 to xmm2/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.0F.WIG 28 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed single-precision floatingpoint values from ymm2/mem to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVAPS</mnem>
			<args>ymm2/m256,ymm1</args>
			<opc openc="MR">VEX.256.0F.WIG 29 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed single-precision floatingpoint values from ymm1 to ymm2/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVBE--Move Data After Swapping Bytes.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVBE</mnem>
			<args>r16,m16</args>
			<opc openc="RM">0F 38 F0 /r</opc>
			<dscrp>Reverse byte order in m16 and move to r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVBE</mnem>
			<args>r32,m32</args>
			<opc openc="RM">0F 38 F0 /r</opc>
			<dscrp>Reverse byte order in m32 and move to r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVBE</mnem>
			<args>r64,m64</args>
			<opc openc="RM">REX.W + 0F 38 F0 /r</opc>
			<dscrp>Reverse byte order in m64 and move to r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVBE</mnem>
			<args>m16,r16</args>
			<opc openc="MR">0F 38 F1 /r</opc>
			<dscrp>Reverse byte order in r16 and move to m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVBE</mnem>
			<args>m32,r32</args>
			<opc openc="MR">0F 38 F1 /r</opc>
			<dscrp>Reverse byte order in r32 and move to m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVBE</mnem>
			<args>m64,r64</args>
			<opc openc="MR">REX.W + 0F 38 F1 /r</opc>
			<dscrp>Reverse byte order in r64 and move to m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVD/MOVQ--Move Doubleword/Move Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVD</mnem>
			<args>mm,r/m32</args>
			<opc openc="RM">0F 6E /r</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Move doubleword from r/m32 to mm.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVQ</mnem>
			<args>mm,r/m64</args>
			<opc openc="RM">REX.W + 0F 6E /r</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Move quadword from r/m64 to mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVD</mnem>
			<args>r/m32,mm</args>
			<opc openc="MR">0F 7E /r</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Move doubleword from mm to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVQ</mnem>
			<args>r/m64,mm</args>
			<opc openc="MR">REX.W + 0F 7E /r</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Move quadword from mm to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVD</mnem>
			<args>xmm1,r32/m32</args>
			<opc openc="RM">VEX.128.66.0F.W0 6E /</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move doubleword from r/m32 to xmm1.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>VMOVQ</mnem>
			<args>xmm1,r64/m64</args>
			<opc openc="RM">VEX.128.66.0F.W1 6E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move quadword from r/m64 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVD</mnem>
			<args>xmm,r/m32</args>
			<opc openc="RM">66 0F 6E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move doubleword from r/m32 to xmm.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVQ</mnem>
			<args>xmm,r/m64</args>
			<opc openc="RM">66 REX.W 0F 6E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move quadword from r/m64 to xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVD</mnem>
			<args>r/m32,xmm</args>
			<opc openc="MR">66 0F 7E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move doubleword from xmm register to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVQ</mnem>
			<args>r/m64,xmm</args>
			<opc openc="MR">66 REX.W 0F 7E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move quadword from xmm register to r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVD</mnem>
			<args>r32/m32,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.W0 7E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move doubleword from xmm1 register to r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>VMOVQ</mnem>
			<args>r64/m64,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.W1 7E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move quadword from xmm1 register to r/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVDDUP--Move One Double-FP and Duplicate.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVDDUP</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 12 /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDDUP</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.F2.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point values from xmm2/mem and duplicate into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDDUP</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.F2.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move even index double-precision floatingpoint values from ymm2/mem and duplicate each element into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVDQA--Move Aligned Double Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVDQA</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 6F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move aligned double quadword from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVDQA</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">66 0F 7F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move aligned double quadword from xmm1 to xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQA</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG 6F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed integer values from xmm2/mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQA</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG 7F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed integer values from xmm1 to xmm2/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQA</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG 6F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed integer values from ymm2/mem to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQA</mnem>
			<args>ymm2/m256,ymm1</args>
			<opc openc="MR">VEX.256.66.0F.WIG 7F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move aligned packed integer values from ymm1 to ymm2/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVDQU--Move Unaligned Double Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVDQU</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F3 0F 6F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move unaligned double quadword from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVDQU</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">F3 0F 7F /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move unaligned double quadword from xmm1 to xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQU</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.F3.0F.WIG 6F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed integer values from xmm2/mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQU</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">VEX.128.F3.0F.WIG 7F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed integer values from xmm1 to xmm2/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQU</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.F3.0F.WIG 6F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed integer values from ymm2/mem to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVDQU</mnem>
			<args>ymm2/m256,ymm1</args>
			<opc openc="MR">VEX.256.F3.0F.WIG 7F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed integer values from ymm1 to ymm2/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVDQ2Q--Move Quadword from XMM to MMX Technology Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVDQ2Q</mnem>
			<args>mm,xmm</args>
			<opc openc="RM">F2 0F D6 /r</opc>
			<dscrp>Move low quadword from xmm to mmx register.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVHLPS--Move Packed Single-Precision Floating-Point Values High to Low.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVHLPS</mnem>
			<args>xmm1,xmm2</args>
			<opc openc="RM">0F 12 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from high quadword of xmm2 to low quadword of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVHLPS</mnem>
			<args>xmm1,xmm2,xmm3</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge two packed single-precision floatingpoint values from high quadword of xmm3 and low quadword of xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVHPD--Move High Packed Double-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVHPD</mnem>
			<args>xmm,m64</args>
			<opc openc="RM">66 0F 16 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point value from m64 to high quadword of xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVHPD</mnem>
			<args>m64,xmm</args>
			<opc openc="MR">66 0F 17 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point value from high quadword of xmm to m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVHPD</mnem>
			<args>xmm2,xmm1,m64</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 16 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge double-precision floating-point value from m64 and the low quadword of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVHPD</mnem>
			<args>m64,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG 17/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point values from high quadword of xmm1 to m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVHPS--Move High Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVHPS</mnem>
			<args>xmm,m64</args>
			<opc openc="RM">0F 16 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from m64 to high quadword of xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVHPS</mnem>
			<args>m64,xmm</args>
			<opc openc="MR">0F 17 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from high quadword of xmm to m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVHPS</mnem>
			<args>xmm2,xmm1,m64</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 16 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge two packed single-precision floatingpoint values from m64 and the low quadword of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVHPS</mnem>
			<args>m64,xmm1</args>
			<opc openc="MR">VEX.128.0F.WIG 17/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from high quadword of xmm1to m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVLHPS--Move Packed Single-Precision Floating-Point Values Low to High.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVLHPS</mnem>
			<args>xmm1,xmm2</args>
			<opc openc="RM">0F 16 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from low quadword of xmm2 to high quadword of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVLHPS</mnem>
			<args>xmm1,xmm2,xmm3</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 16 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge two packed single-precision floatingpoint values from low quadword of xmm3 and low quadword of xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVLPD--Move Low Packed Double-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVLPD</mnem>
			<args>xmm,m64</args>
			<opc openc="RM">66 0F 12 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point value from m64 to low quadword of xmm register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVLPD</mnem>
			<args>m64,xmm</args>
			<opc openc="MR">66 0F 13 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point nvalue from low quadword of xmm register to m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVLPD</mnem>
			<args>xmm2,xmm1,m64</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge double-precision floating-point value from m64 and the high quadword of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVLPD</mnem>
			<args>m64,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG 13/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move double-precision floating-point values from low quadword of xmm1 to m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVLPS--Move Low Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVLPS</mnem>
			<args>xmm,m64</args>
			<opc openc="RM">0F 12 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from m64 to low quadword of xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVLPS</mnem>
			<args>m64,xmm</args>
			<opc openc="MR">0F 13 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from low quadword of xmm to m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVLPS</mnem>
			<args>xmm2,xmm1,m64</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge two packed single-precision floatingpoint values from m64 and the high quadword of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVLPS</mnem>
			<args>m64,xmm1</args>
			<opc openc="MR">VEX.128.0F.WIG 13/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move two packed single-precision floatingpoint values from low quadword of xmm1 to m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVMSKPD--Extract Packed Double-Precision Floating-Point Sign Mask.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVMSKPD</mnem>
			<args>reg,xmm</args>
			<opc openc="RM">66 0F 50 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVMSKPD</mnem>
			<args>reg,xmm2</args>
			<opc openc="RM">VEX.128.66.0F.WIG 50 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVMSKPD</mnem>
			<args>reg,ymm2</args>
			<opc openc="RM">VEX.256.66.0F.WIG 50 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVMSKPS--Extract Packed Single-Precision Floating-Point Sign Mask.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVMSKPS</mnem>
			<args>reg,xmm</args>
			<opc openc="RM">0F 50 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVMSKPS</mnem>
			<args>reg,xmm2</args>
			<opc openc="RM">VEX.128.0F.WIG 50 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVMSKPS</mnem>
			<args>reg,ymm2</args>
			<opc openc="RM">VEX.256.0F.WIG 50 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVNTDQA--Load Double Quadword Non-Temporal Aligned Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVNTDQA</mnem>
			<args>xmm1,m128</args>
			<opc openc="RM">66 0F 38 2A /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Move double quadword from m128 to xmm using non-temporal hint if WC memory type.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTDQA</mnem>
			<args>xmm1,m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 2A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move double quadword from m128 to xmm using non-temporal hint if WC memory type.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTDQA</mnem>
			<args>ymm1,m256</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 2A /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVNTDQ--Store Double Quadword Using Non-Temporal Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVNTDQ</mnem>
			<args>m128,xmm</args>
			<opc openc="MR">66 0F E7 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move double quadword from xmm to m128 using non-temporal hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTDQ</mnem>
			<args>m128,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG E7 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move packed integer values in xmm1 to m128 using non-temporal hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTDQ</mnem>
			<args>m256,ymm1</args>
			<opc openc="MR">VEX.256.66.0F.WIG E7 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move packed integer values in ymm1 to m256 using non-temporal hint.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVNTI--Store Doubleword Using Non-Temporal Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVNTI</mnem>
			<args>m32,r32</args>
			<opc openc="MR">0F C3 /r</opc>
			<dscrp>Move doubleword from r32 to m32 using nontemporal hint.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVNTI</mnem>
			<args>m64,r64</args>
			<opc openc="MR">REX.W + 0F C3 /r</opc>
			<dscrp>Move quadword from r64 to m64 using nontemporal hint.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVNTPD--Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVNTPD</mnem>
			<args>m128,xmm</args>
			<opc openc="MR">66 0F 2B /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move packed double-precision floating-point values from xmm to m128 using nontemporal hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTPD</mnem>
			<args>m128,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG 2B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move packed double-precision values in xmm1 to m128 using non-temporal hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTPD</mnem>
			<args>m256,ymm1</args>
			<opc openc="MR">VEX.256.66.0F.WIG 2B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move packed double-precision values in ymm1 to m256 using non-temporal hint.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVNTPS--Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVNTPS</mnem>
			<args>m128,xmm</args>
			<opc openc="MR">0F 2B /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move packed single-precision floating-point values from xmm to m128 using nontemporal hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTPS</mnem>
			<args>m128,xmm1</args>
			<opc openc="MR">VEX.128.0F.WIG 2B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move packed single-precision values xmm1 to mem using non-temporal hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVNTPS</mnem>
			<args>m256,ymm1</args>
			<opc openc="MR">VEX.256.0F.WIG 2B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move packed single-precision values ymm1 to mem using non-temporal hint.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVNTQ--Store of Quadword Using Non-Temporal Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVNTQ</mnem>
			<args>m64,mm</args>
			<opc openc="MR">0F E7 /r</opc>
			<dscrp>Move quadword from mm to m64 using nontemporal hint.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVQ--Move Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVQ</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 6F /r</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Move quadword from mm/m64 to mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVQ</mnem>
			<args>mm/m64,mm</args>
			<opc openc="MR">0F 7F /r</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Move quadword from mm to mm/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVQ</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F3 0F 7E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move quadword from xmm2/mem64 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVQ</mnem>
			<args>xmm1,xmm2</args>
			<opc openc="RM">VEX.128.F3.0F.WIG 7E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move quadword from xmm2 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVQ</mnem>
			<args>xmm1,m64</args>
			<opc openc="RM">VEX.128.F3.0F.WIG 7E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Load quadword from m64 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVQ</mnem>
			<args>xmm2/m64,xmm1</args>
			<opc openc="MR">66 0F D6 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move quadword from xmm1 to xmm2/mem64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVQ</mnem>
			<args>xmm1/m64,xmm2</args>
			<opc openc="MR">VEX.128.66.0F.WIG D6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move quadword from xmm2 register to xmm1/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVQ2DQ--Move Quadword from MMX Technology to XMM Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVQ2DQ</mnem>
			<args>xmm,mm</args>
			<opc openc="RM">F3 0F D6 /r</opc>
			<dscrp>Move quadword from mmx to low quadword of xmm.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVS/MOVSB/MOVSW/MOVSD/MOVSQ--Move Data from String to String \.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVS</mnem>
			<args>m8,m8</args>
			<opc openc="NP">A4</opc>
			<dscrp>For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVS</mnem>
			<args>m16,m16</args>
			<opc openc="NP">A5</opc>
			<dscrp>For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVS</mnem>
			<args>m32,m32</args>
			<opc openc="NP">A5</opc>
			<dscrp>For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVS</mnem>
			<args>m64,m64</args>
			<opc openc="NP">REX.W + A5</opc>
			<dscrp>Move qword from address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSB</mnem>
			<args>void</args>
			<opc openc="NP">A4</opc>
			<dscrp>For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSW</mnem>
			<args>void</args>
			<opc openc="NP">A5</opc>
			<dscrp>For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSD</mnem>
			<args>void</args>
			<opc openc="NP">A5</opc>
			<dscrp>For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVSQ</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + A5</opc>
			<dscrp>Move qword from address (R|E)SI to (R|E)DI.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVSD--Move Scalar Double-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 10 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSD</mnem>
			<args>xmm1,xmm2,xmm3</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSD</mnem>
			<args>xmm1,m64</args>
			<opc openc="XM">VEX.LIG.F2.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Load scalar double-precision floating-point value from m64 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSD</mnem>
			<args>xmm2/m64,xmm1</args>
			<opc openc="MR">F2 0F 11 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSD</mnem>
			<args>xmm1,xmm2,xmm3</args>
			<opc openc="MVR">VEX.NDS.LIG.F2.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSD</mnem>
			<args>m64,xmm1</args>
			<opc openc="MR">VEX.LIG.F2.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move scalar double-precision floating-point value from xmm1 register to m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="XM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MVR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:reg(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVSHDUP--Move Packed Single-FP High and Duplicate.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVSHDUP</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F3 0F 16 /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSHDUP</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.F3.0F.WIG 16 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSHDUP</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.F3.0F.WIG 16 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVSLDUP--Move Packed Single-FP Low and Duplicate.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVSLDUP</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">F3 0F 12 /r</opc>
			<cpuid>
				<flag>SSE3</flag>
			</cpuid>
			<dscrp>Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSLDUP</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.F3.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move even index single-precision floatingpoint values from xmm2/mem and duplicate each element into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSLDUP</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.F3.0F.WIG 12 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move even index single-precision floatingpoint values from ymm2/mem and duplicate each element into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVSS--Move Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 10 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSS</mnem>
			<args>xmm1,xmm2,xmm3</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSS</mnem>
			<args>xmm1,m32</args>
			<opc openc="XM">VEX.LIG.F3.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Load scalar single-precision floating-point value from m32 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSS</mnem>
			<args>xmm2/m32,xmm</args>
			<opc openc="MR">F3 0F 11 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSS</mnem>
			<args>xmm1,xmm2,xmm3</args>
			<opc openc="MVR">VEX.NDS.LIG.F3.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVSS</mnem>
			<args>m32,xmm1</args>
			<opc openc="MR">VEX.LIG.F3.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move scalar single-precision floating-point value from xmm1 register to m32.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="XM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MVR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:reg(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVSX/MOVSXD--Move with Sign-Extension.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVSX</mnem>
			<args>r16,r/m8</args>
			<opc openc="RM">0F BE /r</opc>
			<dscrp>Move byte to word with sign-extension.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSX</mnem>
			<args>r32,r/m8</args>
			<opc openc="RM">0F BE /r</opc>
			<dscrp>Move byte to doubleword with signextension.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVSX</mnem>
			<args>r64,r/m8*</args>
			<opc openc="RM">REX + 0F BE /r</opc>
			<dscrp>Move byte to quadword with sign-extension.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVSX</mnem>
			<args>r32,r/m16</args>
			<opc openc="RM">0F BF /r</opc>
			<dscrp>Move word to doubleword, with signextension.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVSX</mnem>
			<args>r64,r/m16</args>
			<opc openc="RM">REX.W + 0F BF /r</opc>
			<dscrp>Move word to quadword with sign-extension.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVSXD</mnem>
			<args>r64,r/m32</args>
			<opc openc="RM">REX.W** + 63 /r</opc>
			<dscrp>Move doubleword to quadword with signextension.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVUPD--Move Unaligned Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVUPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 10 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move packed double-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed double-precision floating-point from xmm2/mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPD</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed double-precision floating-point from ymm2/mem to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVUPD</mnem>
			<args>xmm2/m128,xmm</args>
			<opc openc="MR">66 0F 11 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move packed double-precision floating-point values from xmm1 to xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPD</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">VEX.128.66.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPD</mnem>
			<args>ymm2/m256,ymm1</args>
			<opc openc="MR">VEX.256.66.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVUPS--Move Unaligned Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVUPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 10 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move packed single-precision floating-point values from xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed single-precision floating-point from xmm2/mem to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.0F.WIG 10 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed single-precision floating-point from ymm2/mem to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVUPS</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">0F 11 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move packed single-precision floating-point values from xmm1 to xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPS</mnem>
			<args>xmm2/m128,xmm1</args>
			<opc openc="MR">VEX.128.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMOVUPS</mnem>
			<args>ymm2/m256,ymm1</args>
			<opc openc="MR">VEX.256.0F.WIG 11 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MOVZX--Move with Zero-Extend.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MOVZX</mnem>
			<args>r16,r/m8</args>
			<opc openc="RM">0F B6 /r</opc>
			<dscrp>Move byte to word with zero-extension.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVZX</mnem>
			<args>r32,r/m8</args>
			<opc openc="RM">0F B6 /r</opc>
			<dscrp>Move byte to doubleword, zero-extension.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVZX</mnem>
			<args>r64,r/m8*</args>
			<opc openc="RM">REX.W + 0F B6 /r</opc>
			<dscrp>Move byte to quadword, zero-extension.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MOVZX</mnem>
			<args>r32,r/m16</args>
			<opc openc="RM">0F B7 /r</opc>
			<dscrp>Move word to doubleword, zero-extension.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MOVZX</mnem>
			<args>r64,r/m16</args>
			<opc openc="RM">REX.W + 0F B7 /r</opc>
			<dscrp>Move word to quadword, zero-extension.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MPSADBW--Compute Multiple Packed Sums of Absolute Difference.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MPSADBW</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 42 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMPSADBW</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 42 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMPSADBW</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.WIG 42 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MUL--Unsigned Multiply.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MUL</mnem>
			<args>r/m8*</args>
			<opc openc="M">F6 /4</opc>
			<dscrp>Unsigned multiply (AX &lt;-- AL * r/m8).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MUL</mnem>
			<args>r/m8</args>
			<opc openc="M">REX + F6 /4</opc>
			<dscrp>Unsigned multiply (AX &lt;-- AL * r/m8).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MUL</mnem>
			<args>r/m16</args>
			<opc openc="M">F7 /4</opc>
			<dscrp>Unsigned multiply (DX:AX &lt;-- AX * r/m16).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>MUL</mnem>
			<args>r/m32</args>
			<opc openc="M">F7 /4</opc>
			<dscrp>Unsigned multiply (EDX:EAX &lt;-- EAX * r/m32).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MUL</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + F7 /4</opc>
			<dscrp>Unsigned multiply (RDX:RAX &lt;-- RAX * r/m64).</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MULPD--Multiply Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MULPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 59 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMULPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 59 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMULPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 59 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MULPS--Multiply Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MULPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 59 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values in xmm2/mem by xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMULPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 59 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMULPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 59 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MULSD--Multiply Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MULSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 59 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply the low double-precision floatingpoint value in xmm2/mem64 by low doubleprecision floating-point value in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMULSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 59/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the low double-precision floatingpoint value in xmm3/mem64 by low double precision floating-point value in xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MULSS--Multiply Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MULSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 59 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Multiply the low single-precision floating-point value in xmm2/mem by the low singleprecision floating-point value in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMULSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 59 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the low single-precision floating-point value in xmm3/mem by the low singleprecision floating-point value in xmm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MULX--Unsigned Multiply Without Affecting Flags.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MULX</mnem>
			<args>r32a,r32b,r/m32</args>
			<opc openc="RVM">VEX.NDD.LZ.F2.0F38.W0 F6 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Unsigned multiply of r/m32 with EDX without affecting arithmetic flags.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>MULX</mnem>
			<args>r64a,r64b,r/m64</args>
			<opc openc="RVM">VEX.NDD.LZ.F2.0F38.W1 F6 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Unsigned multiply of r/m64 with RDX without affecting arithmetic flags.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(w)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>RDX/EDX is implied 64/32 bits source</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>MWAIT--Monitor Wait.</brief>
		<ins x32m="V" x64m="V">
			<mnem>MWAIT</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 C9</opc>
			<dscrp>A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>NEG--Two's Complement Negation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>NEG</mnem>
			<args>r/m8</args>
			<opc openc="M">F6 /3</opc>
			<dscrp>Two's complement negate r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>NEG</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + F6 /3</opc>
			<dscrp>Two's complement negate r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>NEG</mnem>
			<args>r/m16</args>
			<opc openc="M">F7 /3</opc>
			<dscrp>Two's complement negate r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>NEG</mnem>
			<args>r/m32</args>
			<opc openc="M">F7 /3</opc>
			<dscrp>Two's complement negate r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>NEG</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + F7 /3</opc>
			<dscrp>Two's complement negate r/m64.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>NOP--No Operation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>NOP</mnem>
			<args>void</args>
			<opc openc="NP">90</opc>
			<dscrp>One byte no-operation instruction.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>NOP</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 1F /0</opc>
			<dscrp>Multi-byte no-operation instruction.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>NOP</mnem>
			<args>r/m32</args>
			<opc openc="M">0F 1F /0</opc>
			<dscrp>Multi-byte no-operation instruction.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>NOT--One's Complement Negation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>NOT</mnem>
			<args>r/m8</args>
			<opc openc="M">F6 /2</opc>
			<dscrp>Reverse each bit of r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>NOT</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + F6 /2</opc>
			<dscrp>Reverse each bit of r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>NOT</mnem>
			<args>r/m16</args>
			<opc openc="M">F7 /2</opc>
			<dscrp>Reverse each bit of r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>NOT</mnem>
			<args>r/m32</args>
			<opc openc="M">F7 /2</opc>
			<dscrp>Reverse each bit of r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>NOT</mnem>
			<args>r/m64</args>
			<opc openc="M">REX.W + F7 /2</opc>
			<dscrp>Reverse each bit of r/m64.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>OR--Logical Inclusive OR.</brief>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>AL,imm8</args>
			<opc openc="I">0C ib</opc>
			<dscrp>AL OR imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>AX,imm16</args>
			<opc openc="I">0D iw</opc>
			<dscrp>AX OR imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">0D id</opc>
			<dscrp>EAX OR imm32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 0D id</opc>
			<dscrp>RAX OR imm32 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">80 /1 ib</opc>
			<dscrp>r/m8 OR imm8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + 80 /1 ib</opc>
			<dscrp>r/m8 OR imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /1 iw</opc>
			<dscrp>r/m16 OR imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /1 id</opc>
			<dscrp>r/m32 OR imm32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /1 id</opc>
			<dscrp>r/m64 OR imm32 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /1 ib</opc>
			<dscrp>r/m16 OR imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /1 ib</opc>
			<dscrp>r/m32 OR imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /1 ib</opc>
			<dscrp>r/m64 OR imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">08 /r</opc>
			<dscrp>r/m8 OR r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r/m8*,r8*</args>
			<opc openc="MR">REX + 08 /r</opc>
			<dscrp>r/m8 OR r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">09 /r</opc>
			<dscrp>r/m16 OR r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">09 /r</opc>
			<dscrp>r/m32 OR r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 09 /r</opc>
			<dscrp>r/m64 OR r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">0A /r</opc>
			<dscrp>r8 OR r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r8*,r/m8*</args>
			<opc openc="RM">REX + 0A /r</opc>
			<dscrp>r8 OR r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">0B /r</opc>
			<dscrp>r16 OR r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OR</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">0B /r</opc>
			<dscrp>r32 OR r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>OR</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 0B /r</opc>
			<dscrp>r64 OR r/m64.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ORPD--Bitwise Logical OR of Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ORPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 56 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise OR of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VORPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 56 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VORPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 56 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ORPS--Bitwise Logical OR of Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ORPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 56 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Bitwise OR of xmm1 and xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VORPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 56 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical OR of packed singleprecision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VORPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 56 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical OR of packed singleprecision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>OUT--Output to Port.</brief>
		<ins x32m="V" x64m="V">
			<mnem>OUT</mnem>
			<args>imm8,AL</args>
			<opc openc="I">E6 ib</opc>
			<dscrp>Output byte in AL to I/O port address imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUT</mnem>
			<args>imm8,AX</args>
			<opc openc="I">E7 ib</opc>
			<dscrp>Output word in AX to I/O port address imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUT</mnem>
			<args>imm8,EAX</args>
			<opc openc="I">E7 ib</opc>
			<dscrp>Output doubleword in EAX to I/O port address imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUT</mnem>
			<args>DX,AL</args>
			<opc openc="NP">EE</opc>
			<dscrp>Output byte in AL to I/O port address in DX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUT</mnem>
			<args>DX,AX</args>
			<opc openc="NP">EF</opc>
			<dscrp>Output word in AX to I/O port address in DX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUT</mnem>
			<args>DX,EAX</args>
			<opc openc="NP">EF</opc>
			<dscrp>Output doubleword in EAX to I/O port address in DX.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>imm8(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>OUTS/OUTSB/OUTSW/OUTSD--Output String to Port.</brief>
		<ins x32m="V" x64m="V">
			<mnem>OUTS</mnem>
			<args>DX,m8</args>
			<opc openc="NP">6E</opc>
			<dscrp>Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUTS</mnem>
			<args>DX,m16</args>
			<opc openc="NP">6F</opc>
			<dscrp>Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUTS</mnem>
			<args>DX,m32</args>
			<opc openc="NP">6F</opc>
			<dscrp>Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUTSB</mnem>
			<args>void</args>
			<opc openc="NP">6E</opc>
			<dscrp>Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUTSW</mnem>
			<args>void</args>
			<opc openc="NP">6F</opc>
			<dscrp>Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>OUTSD</mnem>
			<args>void</args>
			<opc openc="NP">6F</opc>
			<dscrp>Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PABSB/PABSW/PABSD--Packed Absolute Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PABSB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 1C /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PABSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 1C /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PABSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 1D /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PABSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 1D /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PABSD</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 1E /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PABSD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 1E /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPABSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 1C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPABSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 1D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 16bit integers in xmm2/m128 and store UNSIGNED result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPABSD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 1E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 32bit integers in xmm2/m128 and store UNSIGNED result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPABSB</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 1C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPABSW</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 1D /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPABSD</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 1E /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PACKSSWB/PACKSSDW--Pack with Signed Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PACKSSWB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 63 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PACKSSWB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 63 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PACKSSDW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 6B /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PACKSSDW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 6B /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKSSWB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 63 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKSSDW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 6B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKSSWB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 63 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKSSDW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 6B /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PACKUSDW--Pack with Unsigned Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PACKUSDW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 2B /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKUSDW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 2B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKUSDW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 2B /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m128 into 16 packed unsigned word integers in ymm1 using unsigned saturation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PACKUSWB--Pack with Unsigned Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PACKUSWB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 67 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PACKUSWB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 67 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKUSWB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 67 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPACKUSWB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 67 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Converts 16 signed word integers from ymm2 and 16signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PADDB/PADDW/PADDD--Add Packed Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PADDB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F FC /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed byte integers from mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F FC /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed byte integers from xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F FD /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed word integers from mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F FD /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed word integers from xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F FE /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed doubleword integers from mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F FE /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed doubleword integers from xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG FC /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed byte integers from xmm3/m128 and xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG FD /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed word integers from xmm3/m128 and xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG FE /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed doubleword integers from xmm3/m128 and xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG FC /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG FD /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed word integers from ymm2, ymm3/m256 and store in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG FE /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PADDQ--Add Packed Quadword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PADDQ</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F D4 /r1</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add quadword integer mm2/m64 to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D4 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed quadword integers xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D4 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed quadword integers xmm3/m128 and xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D4 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PADDSB/PADDSW--Add Packed Signed Integers with Signed Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PADDSB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F EC /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed signed byte integers from mm/m64 and mm and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F EC /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDSW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F ED /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed signed word integers from mm/m64 and mm and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F ED /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDSB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG EC /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG ED /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDSB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG EC /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG ED /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PADDUSB/PADDUSW--Add Packed Unsigned Integers with Unsigned Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PADDUSB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F DC /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed unsigned byte integers from mm/m64 and mm and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDUSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F DC /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDUSW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F DD /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Add packed unsigned word integers from mm/m64 and mm and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PADDUSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F DD /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDUSB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.660F.WIG DC /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDUSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG DD /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDUSB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG DC /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPADDUSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG DD /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PALIGNR--Packed Align Right.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PALIGNR</mnem>
			<args>mm1,mm2/m64,imm8</args>
			<opc openc="RMI">0F 3A 0F /r ib1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PALIGNR</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 0F /r ib</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPALIGNR</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 0F /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPALIGNR</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.WIG 0F /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PAND--Logical AND.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PAND</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F DB /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Bitwise AND mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PAND</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F DB /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise AND of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPAND</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG DB /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Bitwise AND of xmm3/m128 and xmm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPAND</mnem>
			<args>ymm1,ymm2,ymm3/.m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG DB /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PANDN--Logical AND NOT.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PANDN</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F DF /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Bitwise AND NOT of mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PANDN</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F DF /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise AND NOT of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPANDN</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG DF /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Bitwise AND NOT of xmm3/m128 and xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPANDN</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG DF /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PAUSE--Spin Loop Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PAUSE</mnem>
			<args>void</args>
			<opc openc="NP">F3 90</opc>
			<dscrp>Gives hint to processor that improves performance of spin-wait loops.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PAVGB/PAVGW--Average Packed Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PAVGB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F E0 /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PAVGB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E0,/r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PAVGW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F E3 /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Average packed unsigned word integers from mm2/m64 and mm1 with rounding.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PAVGW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E3 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPAVGB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E0 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPAVGW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E3 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPAVGB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E0 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPAVGW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E3 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PBLENDVB--Variable Blend Packed Bytes.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PBLENDVB</mnem>
			<args>xmm1,xmm2/m128,&lt;XMM0&gt;</args>
			<opc openc="RM">66 0F 38 10 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Select byte values from xmm1 and xmm2/m128 from mask specified in the high values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBLENDVB</mnem>
			<args>xmm1,xmm2,xmm3/m128,xmm4</args>
			<opc openc="RVMR">VEX.NDS.128.66.0F3A.W0 4C /r /is4</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBLENDVB</mnem>
			<args>ymm1,ymm2,ymm3/m256,ymm4</args>
			<opc openc="RVMR">VEX.NDS.256.66.0F3A.W0 4C /r /is4</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Select byte values from ymm2 and ymm3/m256 from mask specified in the high values into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>implicit XMM0</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMR">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)[7:4]</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PBLENDW--Blend Packed Words.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PBLENDW</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 0E /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBLENDW</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 0E /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBLENDW</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.WIG 0E /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCLMULQDQ--Carry-Less Multiplication Quadword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCLMULQDQ</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 44 /r ib</opc>
			<cpuid>
				<flag>PCLMULQDQ</flag>
			</cpuid>
			<dscrp>Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCLMULQDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.WIG 44 /r ib</opc>
			<cpuid>
				<flag>PCLMULQDQ</flag>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPEQB/PCMPEQW/PCMPEQD--Compare Packed Data for Equal.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 74 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Compare packed bytes in mm/m64 and mm for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 74 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed bytes in xmm2/m128 and xmm1 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 75 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Compare packed words in mm/m64 and mm for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 75 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed words in xmm2/m128 and xmm1 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 76 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Compare packed doublewords in mm/m64 and mm for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 76 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed doublewords in xmm2/m128 and xmm1 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 74 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed bytes in xmm3/m128 and xmm2 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 75 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed words in xmm3/m128 and xmm2 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 76 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed doublewords in xmm3/m128 and xmm2 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQB</mnem>
			<args>ymm1,ymm2,ymm3 /m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 74 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed bytes in ymm3/m256 and ymm2 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQW</mnem>
			<args>ymm1,ymm2,ymm3 /m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 75 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed words in ymm3/m256 and ymm2 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQD</mnem>
			<args>ymm1,ymm2,ymm3 /m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 76 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed doublewords in ymm3/m256 and ymm2 for equality.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPEQQ--Compare Packed Qword Data for Equal.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPEQQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 29 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed qwords in xmm2/m128 and xmm1 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 29 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed quadwords in xmm3/m128 and xmm2 for equality.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPEQQ</mnem>
			<args>ymm1,ymm2,ymm3 /m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 29 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed quadwords in ymm3/m256 and ymm2 for equality.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPESTRI--Packed Compare Explicit Length Strings, Return Index.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPESTRI</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 61 /r imm8</opc>
			<cpuid>
				<flag>SSE4_2</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPESTRI</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.WIG 61 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPESTRM--Packed Compare Explicit Length Strings, Return Mask.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPESTRM</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 60 /r imm8</opc>
			<cpuid>
				<flag>SSE4_2</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPESTRM</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.WIG 60 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPGTB/PCMPGTW/PCMPGTD--Compare Packed Signed Integers for Greater Than.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 64 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in mm and mm/m64 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 64 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 65 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in mm and mm/m64 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 65 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 66 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Compare packed signed doubleword integers in mm and mm/m64 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 66 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 64 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 65 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in xmm2 and xmm3/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 66 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 64 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 65 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in ymm2 and ymm3/m256 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 66 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPGTQ--Compare Packed Data for Greater Than.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPGTQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 37 /r</opc>
			<cpuid>
				<flag>SSE4_2</flag>
			</cpuid>
			<dscrp>Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 37 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed qwords in xmm2 and xmm3/m128 for greater than.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPGTQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 37 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed qwords in ymm2 and ymm3/m256 for greater than.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPISTRI--Packed Compare Implicit Length Strings, Return Index.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPISTRI</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RM">66 0F 3A 63 /r imm8</opc>
			<cpuid>
				<flag>SSE4_2</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPISTRI</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RM">VEX.128.66.0F3A.WIG 63 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PCMPISTRM--Packed Compare Implicit Length Strings, Return Mask.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PCMPISTRM</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RM">66 0F 3A 62 /r imm8</opc>
			<cpuid>
				<flag>SSE4_2</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPCMPISTRM</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RM">VEX.128.66.0F3A.WIG 62 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PDEP--Parallel Bits Deposit.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PDEP</mnem>
			<args>r32a,r32b,r/m32</args>
			<opc openc="RVM">VEX.NDS.LZ.F2.0F38.W0 F5 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PDEP</mnem>
			<args>r64a,r64b,r/m64</args>
			<opc openc="RVM">VEX.NDS.LZ.F2.0F38.W1 F5 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PEXT--Parallel Bits Extract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PEXT</mnem>
			<args>r32a,r32b,r/m32</args>
			<opc openc="RVM">VEX.NDS.LZ.F3.0F38.W0 F5 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Parallel extract of bits from r32b using mask in r/m32, result is written to r32a.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PEXT</mnem>
			<args>r64a,r64b,r/m64</args>
			<opc openc="RVM">VEX.NDS.LZ.F3.0F38.W1 F5 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Parallel extract of bits from r64b using mask in r/m64, result is written to r64a.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PEXTRB/PEXTRD/PEXTRQ--Extract Byte/Dword/Qword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PEXTRB</mnem>
			<args>reg/m8,xmm2,imm8</args>
			<opc openc="MRI">66 0F 3A 14 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PEXTRD</mnem>
			<args>r/m32,xmm2,imm8</args>
			<opc openc="MRI">66 0F 3A 16 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PEXTRQ</mnem>
			<args>r/m64,xmm2,imm8</args>
			<opc openc="MRI">66 REX.W 0F 3A 16 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V1">
			<mnem>VPEXTRB</mnem>
			<args>reg/m8,xmm2,imm8</args>
			<opc openc="MRI">VEX.128.66.0F3A.W0 14 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPEXTRD</mnem>
			<args>r32/m32,xmm2,imm8</args>
			<opc openc="MRI">VEX.128.66.0F3A.W0 16 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.</dscrp>
		</ins>
		<ins x32m="i" x64m="V">
			<mnem>VPEXTRQ</mnem>
			<args>r64/m64,xmm2,imm8</args>
			<opc openc="MRI">VEX.128.66.0F3A.W1 16 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.</dscrp>
		</ins>
		<oprndenc openc="MRI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PEXTRW--Extract Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PEXTRW</mnem>
			<args>reg,mm,imm8</args>
			<opc openc="RMI">0F C5 /r ib 1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PEXTRW</mnem>
			<args>reg,xmm,imm8</args>
			<opc openc="RMI">66 0F C5 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PEXTRW</mnem>
			<args>reg/m16,xmm,imm8</args>
			<opc openc="MRI">66 0F 3A 15 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V2">
			<mnem>VPEXTRW</mnem>
			<args>reg,xmm1,imm8</args>
			<opc openc="RMI">VEX.128.66.0F.W0 C5 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zeroextend the result. The upper bits of r64/r32 is filled with zeros.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPEXTRW</mnem>
			<args>reg/m16,xmm2,imm8</args>
			<opc openc="MRI">VEX.128.66.0F3A.W0 15 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MRI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PHADDW/PHADDD--Packed Horizontal Add.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PHADDW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 01 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Add 16-bit integers horizontally, pack to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHADDW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 01 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Add 16-bit integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHADDD</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 02 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Add 32-bit integers horizontally, pack to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHADDD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 02 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Add 32-bit integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHADDW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 01 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add 16-bit integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHADDD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 02 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add 32-bit integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHADDW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 01 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add 16-bit signed integers horizontally, pack to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHADDD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 02 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add 32-bit signed integers horizontally, pack to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PHADDSW--Packed Horizontal Add and Saturate.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PHADDSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 03 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Add 16-bit signed integers horizontally, pack saturated integers to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHADDSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 03 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Add 16-bit signed integers horizontally, pack saturated integers to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHADDSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 03 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Add 16-bit signed integers horizontally, pack saturated integers to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHADDSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 03 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Add 16-bit signed integers horizontally, pack saturated integers to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PHMINPOSUW--Packed Horizontal Word Minimum.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PHMINPOSUW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 41 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the secondlowest word of xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHMINPOSUW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 41 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the secondlowest word of xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PHSUBW/PHSUBD--Packed Horizontal Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PHSUBW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 05 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integers horizontally, pack to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHSUBW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 05 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHSUBD</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 06 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Subtract 32-bit signed integers horizontally, pack to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHSUBD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 06 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Subtract 32-bit signed integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHSUBW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 05 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHSUBD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 06 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract 32-bit signed integers horizontally, pack to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHSUBW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 05 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integers horizontally, pack to ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHSUBD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 06 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract 32-bit signed integers horizontally, pack to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PHSUBSW--Packed Horizontal Subtract and Saturate.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PHSUBSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 07 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integer horizontally, pack saturated integers to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PHSUBSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 07 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHSUBSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 07 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPHSUBSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 07 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PINSRB/PINSRD/PINSRQ--Insert Byte/Dword/Qword.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PINSRB</mnem>
			<args>xmm1,r32/m8,imm8</args>
			<opc openc="RMI">66 0F 3A 20 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PINSRD</mnem>
			<args>xmm1,r/m32,imm8</args>
			<opc openc="RMI">66 0F 3A 22 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PINSRQ</mnem>
			<args>xmm1,r/m64,imm8</args>
			<opc openc="RMI">66 REX.W 0F 3A 22 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V1">
			<mnem>VPINSRB</mnem>
			<args>xmm1,xmm2,r32/m8,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.W0 20 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPINSRD</mnem>
			<args>xmm1,xmm2,r/m32,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.W0 22 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>VPINSRQ</mnem>
			<args>xmm1,xmm2,r/m64,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.W1 22 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PINSRW--Insert Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PINSRW</mnem>
			<args>mm,r32/m16,imm8</args>
			<opc openc="RMI">0F C4 /r ib 1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Insert the low word from r32 or from m16 into mm at the word position specified by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PINSRW</mnem>
			<args>xmm,r32/m16,imm8</args>
			<opc openc="RMI">66 0F C4 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move the low word of r32 or from m16 into xmm at the word position specified by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V2">
			<mnem>VPINSRW</mnem>
			<args>xmm1,xmm2,r32/m16,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F.W0 C4 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMADDUBSW--Multiply and Add Packed Signed and Unsigned Bytes.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMADDUBSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 04 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMADDUBSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 04 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMADDUBSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 04 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMADDUBSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 04 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMADDWD--Multiply and Add Packed Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMADDWD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F F5 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMADDWD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F5 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMADDWD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F5 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMADDWD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F5 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMAXSB--Maximum of Packed Signed Byte Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMAXSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 3C /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXSB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 3C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXSB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 3C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMAXSD--Maximum of Packed Signed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMAXSD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 3D /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXSD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 3D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXSD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 3D /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMAXSW--Maximum of Packed Signed Word Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMAXSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F EE /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare signed word integers in mm2/m64 and mm1 and return maximum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMAXSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F EE /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG EE /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG EE /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in ymm3/m128 and ymm2 and store packed maximum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMAXUB--Maximum of Packed Unsigned Byte Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMAXUB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F DE /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMAXUB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F DE /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXUB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG DE /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXUB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG DE /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMAXUD--Maximum of Packed Unsigned Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMAXUD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 3F /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXUD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 3F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXUD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 3F /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMAXUW--Maximum of Packed Word Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMAXUW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 3E /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXUW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 3E/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMAXUW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 3E /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMINSB--Minimum of Packed Signed Byte Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMINSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 38 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINSB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 38 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINSB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 38 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMINSD--Minimum of Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMINSD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 39 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINSD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 39 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINSD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 39 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMINSW--Minimum of Packed Signed Word Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMINSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F EA /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare signed word integers in mm2/m64 and mm1 and return minimum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMINSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F EA /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG EA /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG EA /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed signed word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMINUB--Minimum of Packed Unsigned Byte Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMINUB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F DA /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMINUB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F DA /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINUB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG DA /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINUB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG DA /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMINUD--Minimum of Packed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMINUD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 3B /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINUD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 3B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINUD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 3B /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMINUW--Minimum of Packed Word Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMINUW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 3A /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINUW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 3A/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMINUW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 3A /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMOVMSKB--Move Byte Mask.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMOVMSKB</mnem>
			<args>reg,mm</args>
			<opc openc="RM">0F D7 /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVMSKB</mnem>
			<args>reg,xmm</args>
			<opc openc="RM">66 0F D7 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVMSKB</mnem>
			<args>reg,xmm1</args>
			<opc openc="RM">VEX.128.66.0F.WIG D7 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVMSKB</mnem>
			<args>reg,ymm1</args>
			<opc openc="RM">VEX.256.66.0F.WIG D7 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMOVSX--Packed Move with Sign Extend.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMOVSXBW</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0f 38 20 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVSXBD</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">66 0f 38 21 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVSXBQ</mnem>
			<args>xmm1,xmm2/m16</args>
			<opc openc="RM">66 0f 38 22 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVSXWD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0f 38 23 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVSXWQ</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">66 0f 38 24 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVSXDQ</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0f 38 25 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXBW</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 20 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXBD</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 21 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXBQ</mnem>
			<args>xmm1,xmm2/m16</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 22 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXWD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 23 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXWQ</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 24 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXDQ</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 25 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXBW</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 20 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXBD</mnem>
			<args>ymm1,xmm2/m64</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 21 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXBQ</mnem>
			<args>ymm1,xmm2/m32</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 22 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXWD</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 23 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXWQ</mnem>
			<args>ymm1,xmm2/m64</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 24 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVSXDQ</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 25 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMOVZX--Packed Move with Zero Extend.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMOVZXBW</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0f 38 30 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVZXBD</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">66 0f 38 31 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVZXBQ</mnem>
			<args>xmm1,xmm2/m16</args>
			<opc openc="RM">66 0f 38 32 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVZXWD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0f 38 33 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVZXWQ</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">66 0f 38 34 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMOVZXDQ</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0f 38 35 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXBW</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 30 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXBD</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 31 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXBQ</mnem>
			<args>xmm1,xmm2/m16</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 32 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXWD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 33 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXWQ</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 34 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXDQ</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 35 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXBW</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 30 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Zero extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 16-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXBD</mnem>
			<args>ymm1,xmm2/m64</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 31 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXBQ</mnem>
			<args>ymm1,xmm2/m32</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 32 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXWD</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 33 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Zero extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXWQ</mnem>
			<args>ymm1,xmm2/m64</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 34 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMOVZXDQ</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 35 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Zero extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULDQ--Multiply Packed Signed Dword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 28 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 28 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 28 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULHRSW--Packed Multiply High with Round and Scale.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULHRSW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 0B /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMULHRSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 0B /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULHRSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 0B /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULHRSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 0B /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULHUW--Multiply Packed Unsigned Integers and Store High Result.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULHUW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F E4 /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMULHUW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E4 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULHUW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E4 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULHUW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E4 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULHW--Multiply Packed Signed Integers and Store High Result.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULHW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F E5 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMULHW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E5 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULHW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E5 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULHW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E5 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULLD--Multiply Packed Signed Dword Integers and Store Low Result.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULLD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 40 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULLD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 40 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULLD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 40 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULLW--Multiply Packed Signed Integers and Store Low Result.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULLW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F D5 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMULLW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D5 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULLW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D5 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULLW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D5 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PMULUDQ--Multiply Packed Unsigned Doubleword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PMULUDQ</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F F4 /r1</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PMULUDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F4 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULUDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F4 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMULUDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F4 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>POP--Pop a Value from the Stack.</brief>
		<ins x32m="V" x64m="V">
			<mnem>POP</mnem>
			<args>r/m16</args>
			<opc openc="M">8F /0</opc>
			<dscrp>Pop top of stack into m16; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>POP</mnem>
			<args>r/m32</args>
			<opc openc="M">8F /0</opc>
			<dscrp>Pop top of stack into m32; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>POP</mnem>
			<args>r/m64</args>
			<opc openc="M">8F /0</opc>
			<dscrp>Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>POP</mnem>
			<args>r16</args>
			<opc openc="O">58+ rw</opc>
			<dscrp>Pop top of stack into r16; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>POP</mnem>
			<args>r32</args>
			<opc openc="O">58+ rd</opc>
			<dscrp>Pop top of stack into r32; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>POP</mnem>
			<args>r64</args>
			<opc openc="O">58+ rd</opc>
			<dscrp>Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>POP</mnem>
			<args>DS</args>
			<opc openc="NP">1F</opc>
			<dscrp>Pop top of stack into DS; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>POP</mnem>
			<args>ES</args>
			<opc openc="NP">07</opc>
			<dscrp>Pop top of stack into ES; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>POP</mnem>
			<args>SS</args>
			<opc openc="NP">17</opc>
			<dscrp>Pop top of stack into SS; increment stack pointer.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>POP</mnem>
			<args>FS</args>
			<opc openc="NP">0F A1</opc>
			<dscrp>Pop top of stack into FS; increment stack pointer by 16 bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>POP</mnem>
			<args>FS</args>
			<opc openc="NP">0F A1</opc>
			<dscrp>Pop top of stack into FS; increment stack pointer by 32 bits.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>POP</mnem>
			<args>FS</args>
			<opc openc="NP">0F A1</opc>
			<dscrp>Pop top of stack into FS; increment stack pointer by 64 bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>POP</mnem>
			<args>GS</args>
			<opc openc="NP">0F A9</opc>
			<dscrp>Pop top of stack into GS; increment stack pointer by 16 bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>POP</mnem>
			<args>GS</args>
			<opc openc="NP">0F A9</opc>
			<dscrp>Pop top of stack into GS; increment stack pointer by 32 bits.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>POP</mnem>
			<args>GS</args>
			<opc openc="NP">0F A9</opc>
			<dscrp>Pop top of stack into GS; increment stack pointer by 64 bits.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="O">
			<oprnd1>opcode + rd(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>POPA/POPAD--Pop All General-Purpose Registers.</brief>
		<ins x32m="V" x64m="I">
			<mnem>POPA</mnem>
			<args>void</args>
			<opc openc="NP">61</opc>
			<dscrp>Pop DI, SI, BP, BX, DX, CX, and AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>POPAD</mnem>
			<args>void</args>
			<opc openc="NP">61</opc>
			<dscrp>Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>POPCNT--Return the Count of Number of Bits Set to 1.</brief>
		<ins x32m="V" x64m="V">
			<mnem>POPCNT</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">F3 0F B8 /r</opc>
			<dscrp>POPCNT on r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>POPCNT</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">F3 0F B8 /r</opc>
			<dscrp>POPCNT on r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>POPCNT</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">F3 REX.W 0F B8 /r</opc>
			<dscrp>POPCNT on r/m64.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>POPF/POPFD/POPFQ--Pop Stack into EFLAGS Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>POPF</mnem>
			<args>void</args>
			<opc openc="NP">9D</opc>
			<dscrp>Pop top of stack into lower 16 bits of EFLAGS.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>POPFD</mnem>
			<args>void</args>
			<opc openc="NP">9D</opc>
			<dscrp>Pop top of stack into EFLAGS.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>POPFQ</mnem>
			<args>void</args>
			<opc openc="NP">9D</opc>
			<dscrp>Pop top of stack and zero-extend into RFLAGS.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>POR--Bitwise Logical OR.</brief>
		<ins x32m="V" x64m="V">
			<mnem>POR</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F EB /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Bitwise OR of mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>POR</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F EB /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise OR of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPOR</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG EB /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Bitwise OR of xmm2/m128 and xmm3.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPOR</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG EB /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Bitwise OR of ymm2/m256 and ymm3.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PREFETCHh--Prefetch Data Into Caches.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PREFETCHT0</mnem>
			<args>m8</args>
			<opc openc="M">0F 18 /1</opc>
			<dscrp>Move data from m8 closer to the processor using T0 hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PREFETCHT1</mnem>
			<args>m8</args>
			<opc openc="M">0F 18 /2</opc>
			<dscrp>Move data from m8 closer to the processor using T1 hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PREFETCHT2</mnem>
			<args>m8</args>
			<opc openc="M">0F 18 /3</opc>
			<dscrp>Move data from m8 closer to the processor using T2 hint.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PREFETCHNTA</mnem>
			<args>m8</args>
			<opc openc="M">0F 18 /0</opc>
			<dscrp>Move data from m8 closer to the processor using NTA hint.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PREFETCHW--Prefetch Data into Caches in Anticipation of a Write.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PREFETCHW</mnem>
			<args>m8</args>
			<opc openc="M">0F 0D /1</opc>
			<cpuid>
				<flag>PRFCHW</flag>
			</cpuid>
			<dscrp>Move data from m8 closer to the processor in anticipation of a write.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PREFETCHWT1--Prefetch Vector Data Into Caches with Intent to Write and T1 Hint.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PREFETCHWT1</mnem>
			<args>m8</args>
			<opc openc="M">0F 0D /2</opc>
			<cpuid>
				<flag>PREFETCHWT1</flag>
			</cpuid>
			<dscrp>Move data from m8 closer to the processor using T1 hint with intent to write.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSADBW--Compute Sum of Absolute Differences.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSADBW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F F6 /r1</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSADBW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F6 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSADBW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F6 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSADBW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F6 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSHUFB--Packed Shuffle Bytes.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSHUFB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 00 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Shuffle bytes in mm1 according to contents of mm2/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSHUFB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 00 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Shuffle bytes in xmm1 according to contents of xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 00 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle bytes in xmm2 according to contents of xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 00 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shuffle bytes in ymm2 according to contents of ymm3/m256.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSHUFD--Shuffle Packed Doublewords.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSHUFD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 70 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F.WIG 70 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFD</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F.WIG 70 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSHUFHW--Shuffle Packed High Words.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSHUFHW</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">F3 0F 70 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFHW</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.F3.0F.WIG 70 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFHW</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.F3.0F.WIG 70 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSHUFLW--Shuffle Packed Low Words.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSHUFLW</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">F2 0F 70 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFLW</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.F2.0F.WIG 70 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSHUFLW</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.F2.0F.WIG 70 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSHUFW--Shuffle Packed Words.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSHUFW</mnem>
			<args>mm1,mm2/m64,imm8</args>
			<opc openc="RMI">0F 70 /r ib</opc>
			<dscrp>Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSIGNB/PSIGNW/PSIGND--Packed SIGN.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSIGNB</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 08 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSIGNB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 08 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSIGNW</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 09 /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSIGNW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 09 /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSIGND</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F 38 0A /r1</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSIGND</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 0A /r</opc>
			<cpuid>
				<flag>SSSE3</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSIGNB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 08 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSIGNW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 09 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSIGND</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.WIG 0A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSIGNB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 08 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Negate packed byte integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSIGNW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 09 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Negate packed 16-bit integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSIGND</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.WIG 0A /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Negate packed doubleword integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSLLDQ--Shift Double Quadword Left Logical.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSLLDQ</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 73 /7 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift xmm1 left by imm8 bytes while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLDQ</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 73 /7 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLDQ</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 73 /7 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="VMI">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSLLW/PSLLD/PSLLQ--Shift Packed Data Left Logical.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSLLW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F F1 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift words in mm left mm/m64 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F1 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift words in xmm1 left by xmm2/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLW</mnem>
			<args>mm1,imm8</args>
			<opc openc="MI">0F 71 /6 ib</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift words in mm left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLW</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 71 /6 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift words in xmm1 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F F2 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift doublewords in mm left by mm/m64 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F2 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLD</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 72 /6 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift doublewords in mm left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLD</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 72 /6 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm1 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLQ</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F F3 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift quadword in mm left by mm/m64 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F3 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLQ</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 73 /6 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift quadword in mm left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSLLQ</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 73 /6 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm1 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F1 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLW</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 71 /6 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift words in xmm2 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F2 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLD</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 72 /6 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm2 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F3 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLQ</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 73 /6 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm2 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLW</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F1 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLW</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 71 /6 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift words in ymm2 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="RVM">
			<mnem>VPSLLD</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F2 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="VMI">
			<mnem>VPSLLD</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 72 /6 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift doublewords in ymm2 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="RVM">
			<mnem>VPSLLQ</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F3 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="VMI">
			<mnem>VPSLLQ</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 73 /6 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift quadwords in ymm2 left by imm8 while shifting in 0s.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="VMI">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSRAW/PSRAD--Shift Packed Data Right Arithmetic.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSRAW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F E1 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift words in mm right by mm/m64 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E1 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAW</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 71 /4 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift words in mm right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAW</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 71 /4 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift words in xmm1 right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F E2 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift doublewords in mm right by mm/m64 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E2 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAD</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 72 /4 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift doublewords in mm right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRAD</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 72 /4 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm1 right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E1 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAW</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 71 /4 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift words in xmm2 right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E2 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAD</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 72 /4 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm2 right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAW</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E1 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAW</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 71 /4 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift words in ymm2 right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAD</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E2 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAD</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 72 /4 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift doublewords in ymm2 right by imm8 while shifting in sign bits.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="VMI">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSRLDQ--Shift Double Quadword Right Logical.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSRLDQ</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 73 /3 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift xmm1 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLDQ</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 73 /3 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift xmm2 right by imm8 bytes while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLDQ</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 73 /3 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift ymm1 right by imm8 bytes while shifting in 0s.</dscrp>
		</ins>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="VMI">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSRLW/PSRLD/PSRLQ--Shift Packed Data Right Logical.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSRLW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F D1 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift words in mm right by amount specified in mm/m64 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D1 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLW</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 71 /2 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift words in mm right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLW</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 71 /2 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift words in xmm1 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F D2 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D2 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLD</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 72 /2 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift doublewords in mm right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLD</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 72 /2 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm1 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLQ</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F D3 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift mm right by amount specified in mm/m64 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D3 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLQ</mnem>
			<args>mm,imm8</args>
			<opc openc="MI">0F 73 /2 ib1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Shift mm right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSRLQ</mnem>
			<args>xmm1,imm8</args>
			<opc openc="MI">66 0F 73 /2 ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm1 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D1 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLW</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 71 /2 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift words in xmm2 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D2 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLD</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 72 /2 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift doublewords in xmm2 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D3 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLQ</mnem>
			<args>xmm1,xmm2,imm8</args>
			<opc openc="VMI">VEX.NDD.128.66.0F.WIG 73 /2 ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shift quadwords in xmm2 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLW</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D1 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLW</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 71 /2 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift words in ymm2 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="RVM">
			<mnem>VPSRLD</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D2 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="VMI">
			<mnem>VPSRLD</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 72 /2 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift doublewords in ymm2 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="RVM">
			<mnem>VPSRLQ</mnem>
			<args>ymm1,ymm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D3 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="VMI">
			<mnem>VPSRLQ</mnem>
			<args>ymm1,ymm2,imm8</args>
			<opc openc="VMI">VEX.NDD.256.66.0F.WIG 73 /2 ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift quadwords in ymm2 right by imm8 while shifting in 0s.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="VMI">
			<oprnd1>VEX.vvvv(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSUBB/PSUBW/PSUBD--Subtract Packed Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSUBB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F F8 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract packed byte integers in mm/m64 from packed byte integers in mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F8 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F F9 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract packed word integers in mm/m64 from packed word integers in mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F F9 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F FA /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F FA /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F8 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed byte integers in xmm3/m128 from xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG F9 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed word integers in xmm3/m128 from xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG FA /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed doubleword integers in xmm3/m128 from xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F8 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed byte integers in ymm3/m256 from ymm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG F9 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed word integers in ymm3/m256 from ymm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG FA /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed doubleword integers in ymm3/m256 from ymm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSUBQ--Subtract Packed Quadword Integers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSUBQ</mnem>
			<args>mm1,mm2/m64</args>
			<opc openc="RM">0F FB /r1</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract quadword integer in mm1 from mm2 /m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F FB /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed quadword integers in xmm1 from xmm2 /m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG FB/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed quadword integers in xmm3/m128 from xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG FB /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed quadword integers in ymm3/m256 from ymm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSUBSB/PSUBSW--Subtract Packed Signed Integers with Signed Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSUBSB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F E8 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E8 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBSW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F E9 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F E9 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBSB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E8 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG E9 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBSB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E8 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG E9 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PSUBUSB/PSUBUSW--Subtract Packed Unsigned Integers with Unsigned Saturation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PSUBUSB</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F D8 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBUSB</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D8 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBUSW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F D9 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PSUBUSW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F D9 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBUSB</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D8 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBUSW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG D9 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBUSB</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D8 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSUBUSW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG D9 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PTEST--Logical Compare.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PTEST</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 38 17 /r</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPTEST</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.WIG 17 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Set ZF and CF depending on bitwise AND and ANDN of sources.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPTEST</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F38.WIG 17 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Set ZF and CF depending on bitwise AND and ANDN of sources.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ--Unpack High Data.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHBW</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 68 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order bytes from mm and mm/m64 into mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHBW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 68 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHWD</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 69 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order words from mm and mm/m64 into mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHWD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 69 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHDQ</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F 6A /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order doublewords from mm and mm/m64 into mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 6A /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKHQDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 6D /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHBW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 68/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHWD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 69/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave high-order words from xmm2 and xmm3/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 6A/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHQDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 6D/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHBW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 68 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHWD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 69 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 6A /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKHQDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 6D /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ--Unpack Low Data.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLBW</mnem>
			<args>mm,mm/m32</args>
			<opc openc="RM">0F 60 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Interleave low-order bytes from mm and mm/m32 into mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLBW</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 60 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLWD</mnem>
			<args>mm,mm/m32</args>
			<opc openc="RM">0F 61 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Interleave low-order words from mm and mm/m32 into mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLWD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 61 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Interleave low-order words from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLDQ</mnem>
			<args>mm,mm/m32</args>
			<opc openc="RM">0F 62 /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Interleave low-order doublewords from mm and mm/m32 into mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 62 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUNPCKLQDQ</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 6C /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLBW</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 60/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLWD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 61/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave low-order words from xmm2 and xmm3/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 62/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLQDQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 6C/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLBW</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 60 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLWD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 61 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 62 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPUNPCKLQDQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 6C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PUSH--Push Word, Doubleword or Quadword Onto the Stack.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>r/m16</args>
			<opc openc="M">FF /6</opc>
			<dscrp>Push r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>PUSH</mnem>
			<args>r/m32</args>
			<opc openc="M">FF /6</opc>
			<dscrp>Push r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PUSH</mnem>
			<args>r/m64</args>
			<opc openc="M">FF /6</opc>
			<dscrp>Push r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>r16</args>
			<opc openc="O">50+rw</opc>
			<dscrp>Push r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>PUSH</mnem>
			<args>r32</args>
			<opc openc="O">50+rd</opc>
			<dscrp>Push r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PUSH</mnem>
			<args>r64</args>
			<opc openc="O">50+rd</opc>
			<dscrp>Push r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>imm8</args>
			<opc openc="I">6A ib</opc>
			<dscrp>Push imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>imm16</args>
			<opc openc="I">68 iw</opc>
			<dscrp>Push imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>imm32</args>
			<opc openc="I">68 id</opc>
			<dscrp>Push imm32.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>PUSH</mnem>
			<args>CS</args>
			<opc openc="NP">0E</opc>
			<dscrp>Push CS.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>PUSH</mnem>
			<args>SS</args>
			<opc openc="NP">16</opc>
			<dscrp>Push SS.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>PUSH</mnem>
			<args>DS</args>
			<opc openc="NP">1E</opc>
			<dscrp>Push DS.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>PUSH</mnem>
			<args>ES</args>
			<opc openc="NP">06</opc>
			<dscrp>Push ES.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>FS</args>
			<opc openc="NP">0F A0</opc>
			<dscrp>Push FS.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PUSH</mnem>
			<args>GS</args>
			<opc openc="NP">0F A8</opc>
			<dscrp>Push GS.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="O">
			<oprnd1>opcode + rd(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>imm8(r)/16/32</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PUSHA/PUSHAD--Push All General-Purpose Registers.</brief>
		<ins x32m="V" x64m="I">
			<mnem>PUSHA</mnem>
			<args>void</args>
			<opc openc="NP">60</opc>
			<dscrp>Push AX, CX, DX, BX, original SP, BP, SI, and DI.</dscrp>
		</ins>
		<ins x32m="V" x64m="I">
			<mnem>PUSHAD</mnem>
			<args>void</args>
			<opc openc="NP">60</opc>
			<dscrp>Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PUSHF/PUSHFD--Push EFLAGS Register onto the Stack.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PUSHF</mnem>
			<args>void</args>
			<opc openc="NP">9C</opc>
			<dscrp>Push lower 16 bits of EFLAGS.</dscrp>
		</ins>
		<ins x32m="V" x64m="NE">
			<mnem>PUSHFD</mnem>
			<args>void</args>
			<opc openc="NP">9C</opc>
			<dscrp>Push EFLAGS.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>PUSHFQ</mnem>
			<args>void</args>
			<opc openc="NP">9C</opc>
			<dscrp>Push RFLAGS.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>PXOR--Logical Exclusive OR.</brief>
		<ins x32m="V" x64m="V">
			<mnem>PXOR</mnem>
			<args>mm,mm/m64</args>
			<opc openc="RM">0F EF /r1</opc>
			<cpuid>
				<flag>MMX</flag>
			</cpuid>
			<dscrp>Bitwise XOR of mm/m64 and mm.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>PXOR</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F EF /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise XOR of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPXOR</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG EF /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Bitwise XOR of xmm3/m128 and xmm2.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPXOR</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG EF /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Bitwise XOR of ymm3/m256 and ymm2.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RCL/RCR/ROL/ROR---Rotate.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /2</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) left once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m8*,1</args>
			<opc openc="M1">REX + D0 /2</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) left once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /2</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) left CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m8*,CL</args>
			<opc openc="MC">REX + D2 /2</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) left CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /2 ib</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) left imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + C0 /2 ib</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) left imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /2</opc>
			<dscrp>Rotate 17 bits (CF, r/m16) left once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /2</opc>
			<dscrp>Rotate 17 bits (CF, r/m16) left CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /2 ib</opc>
			<dscrp>Rotate 17 bits (CF, r/m16) left imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /2</opc>
			<dscrp>Rotate 33 bits (CF, r/m32) left once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /2</opc>
			<dscrp>Rotate 65 bits (CF, r/m64) left once. Uses a 6.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /2</opc>
			<dscrp>Rotate 33 bits (CF, r/m32) left CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /2</opc>
			<dscrp>Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /2 ib</opc>
			<dscrp>Rotate 33 bits (CF, r/m32) left imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCL</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /2 ib</opc>
			<dscrp>Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /3</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) right once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m8*,1</args>
			<opc openc="M1">REX + D0 /3</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) right once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /3</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) right CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m8*,CL</args>
			<opc openc="MC">REX + D2 /3</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) right CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /3 ib</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) right imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + C0 /3 ib</opc>
			<dscrp>Rotate 9 bits (CF, r/m8) right imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /3</opc>
			<dscrp>Rotate 17 bits (CF, r/m16) right once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /3</opc>
			<dscrp>Rotate 17 bits (CF, r/m16) right CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /3 ib</opc>
			<dscrp>Rotate 17 bits (CF, r/m16) right imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /3</opc>
			<dscrp>Rotate 33 bits (CF, r/m32) right once. Uses a 6.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /3</opc>
			<dscrp>Rotate 65 bits (CF, r/m64) right once. Uses a 6.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /3</opc>
			<dscrp>Rotate 33 bits (CF, r/m32) right CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /3</opc>
			<dscrp>Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /3 ib</opc>
			<dscrp>Rotate 33 bits (CF, r/m32) right imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RCR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /3 ib</opc>
			<dscrp>Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /0</opc>
			<dscrp>Rotate 8 bits r/m8 left once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m8*,1</args>
			<opc openc="M1">REX + D0 /0</opc>
			<dscrp>Rotate 8 bits r/m8 left once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /0</opc>
			<dscrp>Rotate 8 bits r/m8 left CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m8*,CL</args>
			<opc openc="MC">REX + D2 /0</opc>
			<dscrp>Rotate 8 bits r/m8 left CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /0 ib</opc>
			<dscrp>Rotate 8 bits r/m8 left imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + C0 /0 ib</opc>
			<dscrp>Rotate 8 bits r/m8 left imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /0</opc>
			<dscrp>Rotate 16 bits r/m16 left once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /0</opc>
			<dscrp>Rotate 16 bits r/m16 left CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /0 ib</opc>
			<dscrp>Rotate 16 bits r/m16 left imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /0</opc>
			<dscrp>Rotate 32 bits r/m32 left once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /0</opc>
			<dscrp>Rotate 64 bits r/m64 left once. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /0</opc>
			<dscrp>Rotate 32 bits r/m32 left CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /0</opc>
			<dscrp>Rotate 64 bits r/m64 left CL times. Uses a 6.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /0 ib</opc>
			<dscrp>Rotate 32 bits r/m32 left imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROL</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /0 ib</opc>
			<dscrp>Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /1</opc>
			<dscrp>Rotate 8 bits r/m8 right once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m8*,1</args>
			<opc openc="M1">REX + D0 /1</opc>
			<dscrp>Rotate 8 bits r/m8 right once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /1</opc>
			<dscrp>Rotate 8 bits r/m8 right CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m8*,CL</args>
			<opc openc="MC">REX + D2 /1</opc>
			<dscrp>Rotate 8 bits r/m8 right CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /1 ib</opc>
			<dscrp>Rotate 8 bits r/m16 right imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + C0 /1 ib</opc>
			<dscrp>Rotate 8 bits r/m16 right imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /1</opc>
			<dscrp>Rotate 16 bits r/m16 right once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /1</opc>
			<dscrp>Rotate 16 bits r/m16 right CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /1 ib</opc>
			<dscrp>Rotate 16 bits r/m16 right imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /1</opc>
			<dscrp>Rotate 32 bits r/m32 right once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /1</opc>
			<dscrp>Rotate 64 bits r/m64 right once. Uses a 6 bit count.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /1</opc>
			<dscrp>Rotate 32 bits r/m32 right CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /1</opc>
			<dscrp>Rotate 64 bits r/m64 right CL times. Uses a 6.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /1 ib</opc>
			<dscrp>Rotate 32 bits r/m32 right imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>ROR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /1 ib</opc>
			<dscrp>Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.</dscrp>
		</ins>
		<oprndenc openc="M1">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>1</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MC">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>CL</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RCPPS--Compute Reciprocals of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RCPPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 53 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VRCPPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.0F.WIG 53 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VRCPPS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.0F.WIG 53 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RCPSS--Compute Reciprocal of Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RCPSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 53 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VRCPSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 53 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDFSBASE/RDGSBASE--Read FS/GS Segment Base.</brief>
		<ins x32m="I" x64m="V">
			<mnem>RDFSBASE</mnem>
			<args>r32</args>
			<opc openc="M">F3 0F AE /0</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the 32-bit destination register with the FS base address.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>RDFSBASE</mnem>
			<args>r64</args>
			<opc openc="M">F3 REX.W 0F AE /0</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the 64-bit destination register with the FS base address.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>RDGSBASE</mnem>
			<args>r32</args>
			<opc openc="M">F3 0F AE /1</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the 32-bit destination register with the GS base address.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>RDGSBASE</mnem>
			<args>r64</args>
			<opc openc="M">F3 REX.W 0F AE /1</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the 64-bit destination register with the GS base address.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDMSR--Read from Model Specific Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDMSR</mnem>
			<args>void</args>
			<opc openc="NP">0F 32</opc>
			<dscrp>Read MSR specified by ECX into EDX:EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDPKRU--Read Protection Key Rights for User Pages.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDPKRU</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 EE</opc>
			<cpuid>
				<flag>OSPKE</flag>
			</cpuid>
			<dscrp>Reads PKRU into EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDPMC--Read Performance-Monitoring Counters.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDPMC</mnem>
			<args>void</args>
			<opc openc="NP">0F 33</opc>
			<dscrp>Read performance-monitoring counter specified by ECX into EDX:EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDRAND--Read Random Number.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDRAND</mnem>
			<args>r16</args>
			<opc openc="M">0F C7 /6</opc>
			<cpuid>
				<flag>RDRAND</flag>
			</cpuid>
			<dscrp>Read a 16-bit random number and store in the destination register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RDRAND</mnem>
			<args>r32</args>
			<opc openc="M">0F C7 /6</opc>
			<cpuid>
				<flag>RDRAND</flag>
			</cpuid>
			<dscrp>Read a 32-bit random number and store in the destination register.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>RDRAND</mnem>
			<args>r64</args>
			<opc openc="M">REX.W + 0F C7 /6</opc>
			<cpuid>
				<flag>RDRAND</flag>
			</cpuid>
			<dscrp>Read a 64-bit random number and store in the destination register.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDSEED--Read Random SEED.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDSEED</mnem>
			<args>r16</args>
			<opc openc="M">0F C7 /7</opc>
			<cpuid>
				<flag>RDSEED</flag>
			</cpuid>
			<dscrp>Read a 16-bit NIST SP800-90B &amp; C compliant random value and store in the destination register.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RDSEED</mnem>
			<args>r32</args>
			<opc openc="M">0F C7 /7</opc>
			<cpuid>
				<flag>RDSEED</flag>
			</cpuid>
			<dscrp>Read a 32-bit NIST SP800-90B &amp; C compliant random value and store in the destination register.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>RDSEED</mnem>
			<args>r64</args>
			<opc openc="M">REX.W + 0F C7 /7</opc>
			<cpuid>
				<flag>RDSEED</flag>
			</cpuid>
			<dscrp>Read a 64-bit NIST SP800-90B &amp; C compliant random value and store in the destination register.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDTSC--Read Time-Stamp Counter.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDTSC</mnem>
			<args>void</args>
			<opc openc="NP">0F 31</opc>
			<dscrp>Read time-stamp counter into EDX:EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RDTSCP--Read Time-Stamp Counter and Processor ID.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RDTSCP</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 F9</opc>
			<dscrp>Read 64-bit time-stamp counter and 32-bit IA32_TSC_AUX value into EDX:EAX and ECX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>REP/REPE/REPZ/REPNE/REPNZ--Repeat String Operation Prefix.</brief>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>INS m8,DX</args>
			<opc openc="NP">F3 6C</opc>
			<dscrp>Input (E)CX bytes from port DX into ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>INS m8,DX</args>
			<opc openc="NP">F3 6C</opc>
			<dscrp>Input RCX bytes from port DX into [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>INS m16,DX</args>
			<opc openc="NP">F3 6D</opc>
			<dscrp>Input (E)CX words from port DX into ES:[(E)DI.].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>INS m32,DX</args>
			<opc openc="NP">F3 6D</opc>
			<dscrp>Input (E)CX doublewords from port DX into ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>INS r/m32,DX</args>
			<opc openc="NP">F3 6D</opc>
			<dscrp>Input RCX default size from port DX into [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>MOVS m8,m8</args>
			<opc openc="NP">F3 A4</opc>
			<dscrp>Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>MOVS m8,m8</args>
			<opc openc="NP">F3 REX.W A4</opc>
			<dscrp>Move RCX bytes from [RSI] to [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>MOVS m16,m16</args>
			<opc openc="NP">F3 A5</opc>
			<dscrp>Move (E)CX words from DS:[(E)SI] to ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>MOVS m32,m32</args>
			<opc openc="NP">F3 A5</opc>
			<dscrp>Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>MOVS m64,m64</args>
			<opc openc="NP">F3 REX.W A5</opc>
			<dscrp>Move RCX quadwords from [RSI] to [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>OUTS DX,r/m8</args>
			<opc openc="NP">F3 6E</opc>
			<dscrp>Output (E)CX bytes from DS:[(E)SI] to port DX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>OUTS DX,r/m8*</args>
			<opc openc="NP">F3 REX.W 6E</opc>
			<dscrp>Output RCX bytes from [RSI] to port DX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>OUTS DX,r/m16</args>
			<opc openc="NP">F3 6F</opc>
			<dscrp>Output (E)CX words from DS:[(E)SI] to port DX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>OUTS DX,r/m32</args>
			<opc openc="NP">F3 6F</opc>
			<dscrp>Output (E)CX doublewords from DS:[(E)SI] to port DX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>OUTS DX,r/m32</args>
			<opc openc="NP">F3 REX.W 6F</opc>
			<dscrp>Output RCX default size from [RSI] to port DX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>LODS AL</args>
			<opc openc="NP">F3 AC</opc>
			<dscrp>Load (E)CX bytes from DS:[(E)SI] to AL.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>LODS AL</args>
			<opc openc="NP">F3 REX.W AC</opc>
			<dscrp>Load RCX bytes from [RSI] to AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>LODS AX</args>
			<opc openc="NP">F3 AD</opc>
			<dscrp>Load (E)CX words from DS:[(E)SI] to AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>LODS EAX</args>
			<opc openc="NP">F3 AD</opc>
			<dscrp>Load (E)CX doublewords from DS:[(E)SI] to EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>LODS RAX</args>
			<opc openc="NP">F3 REX.W AD</opc>
			<dscrp>Load RCX quadwords from [RSI] to RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>STOS m8</args>
			<opc openc="NP">F3 AA</opc>
			<dscrp>Fill (E)CX bytes at ES:[(E)DI] with AL.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>STOS m8</args>
			<opc openc="NP">F3 REX.W AA</opc>
			<dscrp>Fill RCX bytes at [RDI] with AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>STOS m16</args>
			<opc openc="NP">F3 AB</opc>
			<dscrp>Fill (E)CX words at ES:[(E)DI] with AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REP</mnem>
			<args>STOS m32</args>
			<opc openc="NP">F3 AB</opc>
			<dscrp>Fill (E)CX doublewords at ES:[(E)DI] with EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REP</mnem>
			<args>STOS m64</args>
			<opc openc="NP">F3 REX.W AB</opc>
			<dscrp>Fill RCX quadwords at [RDI] with RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPE</mnem>
			<args>CMPS m8,m8</args>
			<opc openc="NP">F3 A6</opc>
			<dscrp>Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPE</mnem>
			<args>CMPS m8,m8</args>
			<opc openc="NP">F3 REX.W A6</opc>
			<dscrp>Find non-matching bytes in [RDI] and [RSI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPE</mnem>
			<args>CMPS m16,m16</args>
			<opc openc="NP">F3 A7</opc>
			<dscrp>Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPE</mnem>
			<args>CMPS m32,m32</args>
			<opc openc="NP">F3 A7</opc>
			<dscrp>Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPE</mnem>
			<args>CMPS m64,m64</args>
			<opc openc="NP">F3 REX.W A7</opc>
			<dscrp>Find non-matching quadwords in [RDI] and [RSI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPE</mnem>
			<args>SCAS m8</args>
			<opc openc="NP">F3 AE</opc>
			<dscrp>Find non-AL byte starting at ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPE</mnem>
			<args>SCAS m8</args>
			<opc openc="NP">F3 REX.W AE</opc>
			<dscrp>Find non-AL byte starting at [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPE</mnem>
			<args>SCAS m16</args>
			<opc openc="NP">F3 AF</opc>
			<dscrp>Find non-AX word starting at ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPE</mnem>
			<args>SCAS m32</args>
			<opc openc="NP">F3 AF</opc>
			<dscrp>Find non-EAX doubleword starting at ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPE</mnem>
			<args>SCAS m64</args>
			<opc openc="NP">F3 REX.W AF</opc>
			<dscrp>Find non-RAX quadword starting at [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPNE</mnem>
			<args>CMPS m8,m8</args>
			<opc openc="NP">F2 A6</opc>
			<dscrp>Find matching bytes in ES:[(E)DI] and DS:[(E)SI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPNE</mnem>
			<args>CMPS m8,m8</args>
			<opc openc="NP">F2 REX.W A6</opc>
			<dscrp>Find matching bytes in [RDI] and [RSI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPNE</mnem>
			<args>CMPS m16,m16</args>
			<opc openc="NP">F2 A7</opc>
			<dscrp>Find matching words in ES:[(E)DI] and DS:[(E)SI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPNE</mnem>
			<args>CMPS m32,m32</args>
			<opc openc="NP">F2 A7</opc>
			<dscrp>Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPNE</mnem>
			<args>CMPS m64,m64</args>
			<opc openc="NP">F2 REX.W A7</opc>
			<dscrp>Find matching doublewords in [RDI] and [RSI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPNE</mnem>
			<args>SCAS m8</args>
			<opc openc="NP">F2 AE</opc>
			<dscrp>Find AL, starting at ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPNE</mnem>
			<args>SCAS m8</args>
			<opc openc="NP">F2 REX.W AE</opc>
			<dscrp>Find AL, starting at [RDI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPNE</mnem>
			<args>SCAS m16</args>
			<opc openc="NP">F2 AF</opc>
			<dscrp>Find AX, starting at ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>REPNE</mnem>
			<args>SCAS m32</args>
			<opc openc="NP">F2 AF</opc>
			<dscrp>Find EAX, starting at ES:[(E)DI].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>REPNE</mnem>
			<args>SCAS m64</args>
			<opc openc="NP">F2 REX.W AF</opc>
			<dscrp>Find RAX, starting at [RDI].</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RET--Return from Procedure.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RET</mnem>
			<args>void</args>
			<opc openc="NP">C3</opc>
			<dscrp>Near return to calling procedure.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RET</mnem>
			<args>void</args>
			<opc openc="NP">CB</opc>
			<dscrp>Far return to calling procedure.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RET</mnem>
			<args>imm16</args>
			<opc openc="I">C2 iw</opc>
			<dscrp>Near return to calling procedure and pop imm16 bytes from stack.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>RET</mnem>
			<args>imm16</args>
			<opc openc="I">CA iw</opc>
			<dscrp>Far return to calling procedure and pop imm16 bytes from stack.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="I">
			<oprnd1>imm16(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RORX--Rotate Right Logical Without Affecting Flags.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RORX</mnem>
			<args>r32,r/m32,imm8</args>
			<opc openc="RMI">VEX.LZ.F2.0F3A.W0 F0 /r ib</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>RORX</mnem>
			<args>r64,r/m64,imm8</args>
			<opc openc="RMI">VEX.LZ.F2.0F3A.W1 F0 /r ib</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>Imm8</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ROUNDPD--Round Packed Double Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ROUNDPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 09 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VROUNDPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.WIG 09 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VROUNDPD</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.WIG 09 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ROUNDPS--Round Packed Single Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ROUNDPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F 3A 08 /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VROUNDPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.WIG 08 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VROUNDPS</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.WIG 08 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ROUNDSD--Round Scalar Double Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ROUNDSD</mnem>
			<args>xmm1,xmm2/m64,imm8</args>
			<opc openc="RMI">66 0F 3A 0B /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VROUNDSD</mnem>
			<args>xmm1,xmm2,xmm3/m64,imm8</args>
			<opc openc="RVMI">VEX.NDS.LIG.66.0F3A.WIG 0B /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>ROUNDSS--Round Scalar Single Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>ROUNDSS</mnem>
			<args>xmm1,xmm2/m32,imm8</args>
			<opc openc="RMI">66 0F 3A 0A /r ib</opc>
			<cpuid>
				<flag>SSE4_1</flag>
			</cpuid>
			<dscrp>Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VROUNDSS</mnem>
			<args>xmm1,xmm2,xmm3/m32,imm8</args>
			<opc openc="RVMI">VEX.NDS.LIG.66.0F3A.WIG 0A /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RSM--Resume from System Management Mode.</brief>
		<ins x32m="V" x64m="I">
			<mnem>RSM</mnem>
			<args>void</args>
			<opc openc="NP">0F AA</opc>
			<dscrp>Resume operation of interrupted program.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RSQRTPS--Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RSQRTPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 52 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VRSQRTPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.0F.WIG 52 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VRSQRTPS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.0F.WIG 52 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>RSQRTSS--Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>RSQRTSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 52 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VRSQRTSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 52 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SAHF--Store AH into Flags.</brief>
		<ins x32m="V" x64m="I*">
			<mnem>SAHF</mnem>
			<args>void</args>
			<opc openc="NP">9E</opc>
			<dscrp>Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SAL/SAR/SHL/SHR--Shift.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /4</opc>
			<dscrp>Multiply r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m8**,1</args>
			<opc openc="M1">REX + D0 /4</opc>
			<dscrp>Multiply r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /4</opc>
			<dscrp>Multiply r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m8**,CL</args>
			<opc openc="MC">REX + D2 /4</opc>
			<dscrp>Multiply r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /4 ib</opc>
			<dscrp>Multiply r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m8**,imm8</args>
			<opc openc="MI">REX + C0 /4 ib</opc>
			<dscrp>Multiply r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /4</opc>
			<dscrp>Multiply r/m16 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /4</opc>
			<dscrp>Multiply r/m16 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /4 ib</opc>
			<dscrp>Multiply r/m16 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /4</opc>
			<dscrp>Multiply r/m32 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /4</opc>
			<dscrp>Multiply r/m64 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /4</opc>
			<dscrp>Multiply r/m32 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /4</opc>
			<dscrp>Multiply r/m64 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /4 ib</opc>
			<dscrp>Multiply r/m32 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAL</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /4 ib</opc>
			<dscrp>Multiply r/m64 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /7</opc>
			<dscrp>Signed divide* r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m8**,1</args>
			<opc openc="M1">REX + D0 /7</opc>
			<dscrp>Signed divide* r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /7</opc>
			<dscrp>Signed divide* r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m8**,CL</args>
			<opc openc="MC">REX + D2 /7</opc>
			<dscrp>Signed divide* r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /7 ib</opc>
			<dscrp>Signed divide* r/m8 by 2, imm8 time.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m8**,imm8</args>
			<opc openc="MI">REX + C0 /7 ib</opc>
			<dscrp>Signed divide* r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /7</opc>
			<dscrp>Signed divide* r/m16 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /7</opc>
			<dscrp>Signed divide* r/m16 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /7 ib</opc>
			<dscrp>Signed divide* r/m16 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /7</opc>
			<dscrp>Signed divide* r/m32 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /7</opc>
			<dscrp>Signed divide* r/m64 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /7</opc>
			<dscrp>Signed divide* r/m32 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /7</opc>
			<dscrp>Signed divide* r/m64 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /7 ib</opc>
			<dscrp>Signed divide* r/m32 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SAR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /7 ib</opc>
			<dscrp>Signed divide* r/m64 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /4</opc>
			<dscrp>Multiply r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m8**,1</args>
			<opc openc="M1">REX + D0 /4</opc>
			<dscrp>Multiply r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /4</opc>
			<dscrp>Multiply r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m8**,CL</args>
			<opc openc="MC">REX + D2 /4</opc>
			<dscrp>Multiply r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /4 ib</opc>
			<dscrp>Multiply r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m8**,imm8</args>
			<opc openc="MI">REX + C0 /4 ib</opc>
			<dscrp>Multiply r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /4</opc>
			<dscrp>Multiply r/m16 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /4</opc>
			<dscrp>Multiply r/m16 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /4 ib</opc>
			<dscrp>Multiply r/m16 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /4</opc>
			<dscrp>Multiply r/m32 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /4</opc>
			<dscrp>Multiply r/m64 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /4</opc>
			<dscrp>Multiply r/m32 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /4</opc>
			<dscrp>Multiply r/m64 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /4 ib</opc>
			<dscrp>Multiply r/m32 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHL</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /4 ib</opc>
			<dscrp>Multiply r/m64 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m8,1</args>
			<opc openc="M1">D0 /5</opc>
			<dscrp>Unsigned divide r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m8**,1</args>
			<opc openc="M1">REX + D0 /5</opc>
			<dscrp>Unsigned divide r/m8 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m8,CL</args>
			<opc openc="MC">D2 /5</opc>
			<dscrp>Unsigned divide r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m8**,CL</args>
			<opc openc="MC">REX + D2 /5</opc>
			<dscrp>Unsigned divide r/m8 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">C0 /5 ib</opc>
			<dscrp>Unsigned divide r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m8**,imm8</args>
			<opc openc="MI">REX + C0 /5 ib</opc>
			<dscrp>Unsigned divide r/m8 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m16,1</args>
			<opc openc="M1">D1 /5</opc>
			<dscrp>Unsigned divide r/m16 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m16,CL</args>
			<opc openc="MC">D3 /5</opc>
			<dscrp>Unsigned divide r/m16 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">C1 /5 ib</opc>
			<dscrp>Unsigned divide r/m16 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m32,1</args>
			<opc openc="M1">D1 /5</opc>
			<dscrp>Unsigned divide r/m32 by 2, once.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m64,1</args>
			<opc openc="M1">REX.W + D1 /5</opc>
			<dscrp>Unsigned divide r/m64 by 2, once.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m32,CL</args>
			<opc openc="MC">D3 /5</opc>
			<dscrp>Unsigned divide r/m32 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m64,CL</args>
			<opc openc="MC">REX.W + D3 /5</opc>
			<dscrp>Unsigned divide r/m64 by 2, CL times.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">C1 /5 ib</opc>
			<dscrp>Unsigned divide r/m32 by 2, imm8 times.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + C1 /5 ib</opc>
			<dscrp>Unsigned divide r/m64 by 2, imm8 times.</dscrp>
		</ins>
		<oprndenc openc="M1">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>1</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MC">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>CL</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SARX/SHLX/SHRX--Shift Without Affecting Flags.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SARX</mnem>
			<args>r32a,r/m32,r32b</args>
			<opc openc="RMV">VEX.NDS.LZ.F3.0F38.W0 F7 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Shift r/m32 arithmetically right with count specified in r32b.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHLX</mnem>
			<args>r32a,r/m32,r32b</args>
			<opc openc="RMV">VEX.NDS.LZ.66.0F38.W0 F7 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Shift r/m32 logically left with count specified in r32b.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHRX</mnem>
			<args>r32a,r/m32,r32b</args>
			<opc openc="RMV">VEX.NDS.LZ.F2.0F38.W0 F7 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Shift r/m32 logically right with count specified in r32b.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SARX</mnem>
			<args>r64a,r/m64,r64b</args>
			<opc openc="RMV">VEX.NDS.LZ.F3.0F38.W1 F7 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Shift r/m64 arithmetically right with count specified in r64b.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHLX</mnem>
			<args>r64a,r/m64,r64b</args>
			<opc openc="RMV">VEX.NDS.LZ.66.0F38.W1 F7 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Shift r/m64 logically left with count specified in r64b.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHRX</mnem>
			<args>r64a,r/m64,r64b</args>
			<opc openc="RMV">VEX.NDS.LZ.F2.0F38.W1 F7 /r</opc>
			<cpuid>
				<flag>BMI2</flag>
			</cpuid>
			<dscrp>Shift r/m64 logically right with count specified in r64b.</dscrp>
		</ins>
		<oprndenc openc="RMV">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>VEX.vvvv(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SBB--Integer Subtraction with Borrow.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>AL,imm8</args>
			<opc openc="I">1C ib</opc>
			<dscrp>Subtract with borrow imm8 from AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>AX,imm16</args>
			<opc openc="I">1D iw</opc>
			<dscrp>Subtract with borrow imm16 from AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">1D id</opc>
			<dscrp>Subtract with borrow imm32 from EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 1D id</opc>
			<dscrp>Subtract with borrow sign-extended imm.32 to 64-bits from RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">80 /3 ib</opc>
			<dscrp>Subtract with borrow imm8 from r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + 80 /3 ib</opc>
			<dscrp>Subtract with borrow imm8 from r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /3 iw</opc>
			<dscrp>Subtract with borrow imm16 from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /3 id</opc>
			<dscrp>Subtract with borrow imm32 from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /3 id</opc>
			<dscrp>Subtract with borrow sign-extended imm32 to 64-bits from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /3 ib</opc>
			<dscrp>Subtract with borrow sign-extended imm8 from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /3 ib</opc>
			<dscrp>Subtract with borrow sign-extended imm8 from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /3 ib</opc>
			<dscrp>Subtract with borrow sign-extended imm8 from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">18 /r</opc>
			<dscrp>Subtract with borrow r8 from r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m8*,r8</args>
			<opc openc="MR">REX + 18 /r</opc>
			<dscrp>Subtract with borrow r8 from r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">19 /r</opc>
			<dscrp>Subtract with borrow r16 from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">19 /r</opc>
			<dscrp>Subtract with borrow r32 from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 19 /r</opc>
			<dscrp>Subtract with borrow r64 from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">1A /r</opc>
			<dscrp>Subtract with borrow r/m8 from r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r8*,r/m8*</args>
			<opc openc="RM">REX + 1A /r</opc>
			<dscrp>Subtract with borrow r/m8 from r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">1B /r</opc>
			<dscrp>Subtract with borrow r/m16 from r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SBB</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">1B /r</opc>
			<dscrp>Subtract with borrow r/m32 from r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SBB</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 1B /r</opc>
			<dscrp>Subtract with borrow r/m64 from r64.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SCAS/SCASB/SCASW/SCASD--Scan String.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SCAS</mnem>
			<args>m8</args>
			<opc openc="NP">AE</opc>
			<dscrp>Compare AL with byte at ES:(E)DI or RDI, then set status flags.*.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SCAS</mnem>
			<args>m16</args>
			<opc openc="NP">AF</opc>
			<dscrp>Compare AX with word at ES:(E)DI or RDI, then set status flags.*.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SCAS</mnem>
			<args>m32</args>
			<opc openc="NP">AF</opc>
			<dscrp>Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SCAS</mnem>
			<args>m64</args>
			<opc openc="NP">REX.W + AF</opc>
			<dscrp>Compare RAX with quadword at RDI or EDI then set status flags.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SCASB</mnem>
			<args>void</args>
			<opc openc="NP">AE</opc>
			<dscrp>Compare AL with byte at ES:(E)DI or RDI then set status flags.*.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SCASW</mnem>
			<args>void</args>
			<opc openc="NP">AF</opc>
			<dscrp>Compare AX with word at ES:(E)DI or RDI then set status flags.*.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SCASD</mnem>
			<args>void</args>
			<opc openc="NP">AF</opc>
			<dscrp>Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SCASQ</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + AF</opc>
			<dscrp>Compare RAX with quadword at RDI or EDI then set status flags.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SETcc--Set Byte on Condition.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SETA</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 97</opc>
			<dscrp>Set byte if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETA</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 97</opc>
			<dscrp>Set byte if above (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETAE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 93</opc>
			<dscrp>Set byte if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETAE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 93</opc>
			<dscrp>Set byte if above or equal (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETB</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 92</opc>
			<dscrp>Set byte if below (CF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETB</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 92</opc>
			<dscrp>Set byte if below (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETBE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 96</opc>
			<dscrp>Set byte if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETBE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 96</opc>
			<dscrp>Set byte if below or equal (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETC</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 92</opc>
			<dscrp>Set byte if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETC</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 92</opc>
			<dscrp>Set byte if carry (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 94</opc>
			<dscrp>Set byte if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 94</opc>
			<dscrp>Set byte if equal (ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETG</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9F</opc>
			<dscrp>Set byte if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETG</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9F</opc>
			<dscrp>Set byte if greater (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETGE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9D</opc>
			<dscrp>Set byte if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETGE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9D</opc>
			<dscrp>Set byte if greater or equal (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETL</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9C</opc>
			<dscrp>Set byte if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETL</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9C</opc>
			<dscrp>Set byte if less (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETLE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9E</opc>
			<dscrp>Set byte if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETLE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9E</opc>
			<dscrp>Set byte if less or equal (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNA</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 96</opc>
			<dscrp>Set byte if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNA</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 96</opc>
			<dscrp>Set byte if not above (CF=1 or ZF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNAE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 92</opc>
			<dscrp>Set byte if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNAE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 92</opc>
			<dscrp>Set byte if not above or equal (CF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNB</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 93</opc>
			<dscrp>Set byte if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNB</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 93</opc>
			<dscrp>Set byte if not below (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNBE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 97</opc>
			<dscrp>Set byte if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNBE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 97</opc>
			<dscrp>Set byte if not below or equal (CF=0 and ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNC</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 93</opc>
			<dscrp>Set byte if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNC</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 93</opc>
			<dscrp>Set byte if not carry (CF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 95</opc>
			<dscrp>Set byte if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 95</opc>
			<dscrp>Set byte if not equal (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNG</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9E</opc>
			<dscrp>Set byte if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNG</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9E</opc>
			<dscrp>Set byte if not greater (ZF=1 or SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNGE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9C</opc>
			<dscrp>Set byte if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNGE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9C</opc>
			<dscrp>Set byte if not greater or equal (SF != OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNL</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9D</opc>
			<dscrp>Set byte if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNL</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9D</opc>
			<dscrp>Set byte if not less (SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNLE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9F</opc>
			<dscrp>Set byte if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNLE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9F</opc>
			<dscrp>Set byte if not less or equal (ZF=0 and SF=OF).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNO</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 91</opc>
			<dscrp>Set byte if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNO</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 91</opc>
			<dscrp>Set byte if not overflow (OF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNP</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9B</opc>
			<dscrp>Set byte if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNP</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9B</opc>
			<dscrp>Set byte if not parity (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNS</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 99</opc>
			<dscrp>Set byte if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNS</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 99</opc>
			<dscrp>Set byte if not sign (SF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETNZ</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 95</opc>
			<dscrp>Set byte if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETNZ</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 95</opc>
			<dscrp>Set byte if not zero (ZF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETO</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 90</opc>
			<dscrp>Set byte if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETO</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 90</opc>
			<dscrp>Set byte if overflow (OF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETP</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9A</opc>
			<dscrp>Set byte if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETP</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9A</opc>
			<dscrp>Set byte if parity (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETPE</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9A</opc>
			<dscrp>Set byte if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETPE</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9A</opc>
			<dscrp>Set byte if parity even (PF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETPO</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 9B</opc>
			<dscrp>Set byte if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETPO</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 9B</opc>
			<dscrp>Set byte if parity odd (PF=0).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETS</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 98</opc>
			<dscrp>Set byte if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETS</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 98</opc>
			<dscrp>Set byte if sign (SF=1).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SETZ</mnem>
			<args>r/m8</args>
			<opc openc="M">0F 94</opc>
			<dscrp>Set byte if zero (ZF=1).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SETZ</mnem>
			<args>r/m8*</args>
			<opc openc="M">REX + 0F 94</opc>
			<dscrp>Set byte if zero (ZF=1).</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SFENCE--Store Fence.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SFENCE</mnem>
			<args>void</args>
			<opc openc="NP">0F AE F8</opc>
			<dscrp>Serializes store operations.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SGDT--Store Global Descriptor Table Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SGDT</mnem>
			<args>m</args>
			<opc openc="M">0F 01 /0</opc>
			<dscrp>Store GDTR to m.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SHLD--Double Precision Shift Left.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SHLD</mnem>
			<args>r/m16,r16,imm8</args>
			<opc openc="MRI">0F A4 /r ib</opc>
			<dscrp>Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHLD</mnem>
			<args>r/m16,r16,CL</args>
			<opc openc="MRC">0F A5 /r</opc>
			<dscrp>Shift r/m16 to left CL places while shifting bits from r16 in from the right.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHLD</mnem>
			<args>r/m32,r32,imm8</args>
			<opc openc="MRI">0F A4 /r ib</opc>
			<dscrp>Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHLD</mnem>
			<args>r/m64,r64,imm8</args>
			<opc openc="MRI">REX.W + 0F A4 /r ib</opc>
			<dscrp>Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHLD</mnem>
			<args>r/m32,r32,CL</args>
			<opc openc="MRC">0F A5 /r</opc>
			<dscrp>Shift r/m32 to left CL places while shifting bits from r32 in from the right.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHLD</mnem>
			<args>r/m64,r64,CL</args>
			<opc openc="MRC">REX.W + 0F A5 /r</opc>
			<dscrp>Shift r/m64 to left CL places while shifting bits from r64 in from the right.</dscrp>
		</ins>
		<oprndenc openc="MRI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MRC">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>CL</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SHRD--Double Precision Shift Right.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SHRD</mnem>
			<args>r/m16,r16,imm8</args>
			<opc openc="MRI">0F AC /r ib</opc>
			<dscrp>Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHRD</mnem>
			<args>r/m16,r16,CL</args>
			<opc openc="MRC">0F AD /r</opc>
			<dscrp>Shift r/m16 to right CL places while shifting bits from r16 in from the left.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHRD</mnem>
			<args>r/m32,r32,imm8</args>
			<opc openc="MRI">0F AC /r ib</opc>
			<dscrp>Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHRD</mnem>
			<args>r/m64,r64,imm8</args>
			<opc openc="MRI">REX.W + 0F AC /r ib</opc>
			<dscrp>Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SHRD</mnem>
			<args>r/m32,r32,CL</args>
			<opc openc="MRC">0F AD /r</opc>
			<dscrp>Shift r/m32 to right CL places while shifting bits from r32 in from the left.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SHRD</mnem>
			<args>r/m64,r64,CL</args>
			<opc openc="MRC">REX.W + 0F AD /r</opc>
			<dscrp>Shift r/m64 to right CL places while shifting bits from r64 in from the left.</dscrp>
		</ins>
		<oprndenc openc="MRI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MRC">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>CL</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SHUFPD--Shuffle Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SHUFPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">66 0F C6 /r ib</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Shuffle packed double-precision floatingpoint values selected by imm8 from xmm1 and xmm2/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSHUFPD</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F.WIG C6 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle Packed double-precision floatingpoint values selected by imm8 from xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSHUFPD</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F.WIG C6 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle Packed double-precision floatingpoint values selected by imm8 from ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SHUFPS--Shuffle Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SHUFPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">0F C6 /r ib</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSHUFPS</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.0F.WIG C6 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle Packed single-precision floating-point values selected by imm8 from xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSHUFPS</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.0F.WIG C6 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Shuffle Packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SIDT--Store Interrupt Descriptor Table Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SIDT</mnem>
			<args>m</args>
			<opc openc="M">0F 01 /1</opc>
			<dscrp>Store IDTR to m.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SLDT--Store Local Descriptor Table Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SLDT</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 00 /0</opc>
			<dscrp>Stores segment selector from LDTR in r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SLDT</mnem>
			<args>r64/m16</args>
			<opc openc="M">REX.W + 0F 00 /0</opc>
			<dscrp>Stores segment selector from LDTR in r64/m16.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SMSW--Store Machine Status Word.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SMSW</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 01 /4</opc>
			<dscrp>Store machine status word to r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SMSW</mnem>
			<args>r32/m16</args>
			<opc openc="M">0F 01 /4</opc>
			<dscrp>Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SMSW</mnem>
			<args>r64/m16</args>
			<opc openc="M">REX.W + 0F 01 /4</opc>
			<dscrp>Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SQRTPD--Compute Square Roots of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SQRTPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 51 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Computes square roots of the packed doubleprecision floating-point values in xmm2/m128 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSQRTPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F.WIG 51 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes Square Roots of the packed doubleprecision floating-point values in xmm2/m128 and stores the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSQRTPD</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F.WIG 51/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes Square Roots of the packed doubleprecision floating-point values in ymm2/m256 and stores the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SQRTPS--Compute Square Roots of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SQRTPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 51 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes square roots of the packed singleprecision floating-point values in xmm2/m128 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSQRTPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.0F.WIG 51 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes Square Roots of the packed singleprecision floating-point values in xmm2/m128 and stores the result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSQRTPS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.0F.WIG 51/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes Square Roots of the packed singleprecision floating-point values in ymm2/m256 and stores the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SQRTSD--Compute Square Root of Scalar Double-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SQRTSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 51 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Computes square root of the low doubleprecision floating-point value in xmm2/m64 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSQRTSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 51/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes square root of the low doubleprecision floating point value in xmm3/m64 and stores the results in xmm2. Also, upper double precision floating-point value (bits[127:64]) from xmm2 are copied to xmm1[127:64].</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SQRTSS--Compute Square Root of Scalar Single-Precision Floating-Point Value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SQRTSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 51 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Computes square root of the low singleprecision floating-point value in xmm2/m32 and stores the results in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSQRTSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 51/r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Computes square root of the low singleprecision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STAC--Set AC Flag in EFLAGS Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STAC</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 CB</opc>
			<dscrp>Set the AC flag in the EFLAGS register.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STC--Set Carry Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STC</mnem>
			<args>void</args>
			<opc openc="NP">F9</opc>
			<dscrp>Set CF flag.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STD--Set Direction Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STD</mnem>
			<args>void</args>
			<opc openc="NP">FD</opc>
			<dscrp>Set DF flag.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STI--Set Interrupt Flag.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STI</mnem>
			<args>void</args>
			<opc openc="NP">FB</opc>
			<dscrp>Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STMXCSR--Store MXCSR Register State.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STMXCSR</mnem>
			<args>m32</args>
			<opc openc="M">0F AE /3</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Store contents of MXCSR register to m32.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSTMXCSR</mnem>
			<args>m32</args>
			<opc openc="M">VEX.LZ.0F.WIG AE /3</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Store contents of MXCSR register to m32.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STOS/STOSB/STOSW/STOSD/STOSQ--Store String.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STOS</mnem>
			<args>m8</args>
			<opc openc="NA">AA</opc>
			<dscrp>For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>STOS</mnem>
			<args>m16</args>
			<opc openc="NA">AB</opc>
			<dscrp>For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>STOS</mnem>
			<args>m32</args>
			<opc openc="NA">AB</opc>
			<dscrp>For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>STOS</mnem>
			<args>m64</args>
			<opc openc="NA">REX.W + AB</opc>
			<dscrp>Store RAX at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>STOSB</mnem>
			<args>void</args>
			<opc openc="NA">AA</opc>
			<dscrp>For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>STOSW</mnem>
			<args>void</args>
			<opc openc="NA">AB</opc>
			<dscrp>For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>STOSD</mnem>
			<args>void</args>
			<opc openc="NA">AB</opc>
			<dscrp>For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>STOSQ</mnem>
			<args>void</args>
			<opc openc="NA">REX.W + AB</opc>
			<dscrp>Store RAX at address RDI or EDI.</dscrp>
		</ins>
		<oprndenc openc="NA">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>STR--Store Task Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>STR</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 00 /1</opc>
			<dscrp>Stores segment selector from TR in r/m16.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SUB--Subtract.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>AL,imm8</args>
			<opc openc="I">2C ib</opc>
			<dscrp>Subtract imm8 from AL.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>AX,imm16</args>
			<opc openc="I">2D iw</opc>
			<dscrp>Subtract imm16 from AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">2D id</opc>
			<dscrp>Subtract imm32 from EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 2D id</opc>
			<dscrp>Subtract imm32 sign-extended to 64-bits from RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">80 /5 ib</opc>
			<dscrp>Subtract imm8 from r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + 80 /5 ib</opc>
			<dscrp>Subtract imm8 from r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /5 iw</opc>
			<dscrp>Subtract imm16 from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /5 id</opc>
			<dscrp>Subtract imm32 from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /5 id</opc>
			<dscrp>Subtract imm32 sign-extended to 64-bits from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /5 ib</opc>
			<dscrp>Subtract sign-extended imm8 from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /5 ib</opc>
			<dscrp>Subtract sign-extended imm8 from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /5 ib</opc>
			<dscrp>Subtract sign-extended imm8 from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">28 /r</opc>
			<dscrp>Subtract r8 from r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m8*,r8*</args>
			<opc openc="MR">REX + 28 /r</opc>
			<dscrp>Subtract r8 from r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">29 /r</opc>
			<dscrp>Subtract r16 from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">29 /r</opc>
			<dscrp>Subtract r32 from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 29 /r</opc>
			<dscrp>Subtract r64 from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">2A /r</opc>
			<dscrp>Subtract r/m8 from r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r8*,r/m8*</args>
			<opc openc="RM">REX + 2A /r</opc>
			<dscrp>Subtract r/m8 from r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">2B /r</opc>
			<dscrp>Subtract r/m16 from r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SUB</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">2B /r</opc>
			<dscrp>Subtract r/m32 from r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>SUB</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 2B /r</opc>
			<dscrp>Subtract r/m64 from r64.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)/26/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)/26/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SUBPD--Subtract Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SUBPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 5C /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtract packed double-precision floatingpoint values in xmm2/m128 from xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSUBPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 5C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed double-precision floatingpoint values in xmm3/mem from xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSUBPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 5C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed double-precision floatingpoint values in ymm3/mem from ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SUBPS--Subtract Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SUBPS</mnem>
			<args>xmm1 xmm2/m128</args>
			<opc openc="RM">0F 5C /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Subtract packed single-precision floating-point values in xmm2/mem from xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSUBPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 5C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSUBPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 5C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SUBSD--Subtract Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SUBSD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">F2 0F 5C /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Subtracts the low double-precision floatingpoint values in xmm2/mem64 from xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSUBSD</mnem>
			<args>xmm1,xmm2,xmm3/m64</args>
			<opc openc="RVM">VEX.NDS.LIG.F2.0F.WIG 5C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract the low double-precision floatingpoint value in xmm3/mem from xmm2 and store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SUBSS--Subtract Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SUBSS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">F3 0F 5C /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Subtract the lower single-precision floatingpoint values in xmm2/m32 from xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VSUBSS</mnem>
			<args>xmm1,xmm2,xmm3/m32</args>
			<opc openc="RVM">VEX.NDS.LIG.F3.0F.WIG 5C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Subtract the low single-precision floatingpoint value in xmm3/mem from xmm2 and store the result in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SWAPGS--Swap GS Base Register.</brief>
		<ins x32m="I" x64m="V">
			<mnem>SWAPGS</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 F8</opc>
			<dscrp>Exchanges the current GS base register value with the value contained in MSR address C0000102H.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SYSCALL--Fast System Call.</brief>
		<ins x32m="I" x64m="V">
			<mnem>SYSCALL</mnem>
			<args>void</args>
			<opc openc="NP">0F 05</opc>
			<dscrp>Fast call to privilege level 0 system procedures.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SYSENTER--Fast System Call.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SYSENTER</mnem>
			<args>void</args>
			<opc openc="NP">0F 34</opc>
			<dscrp>Fast call to privilege level 0 system procedures.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SYSEXIT--Fast Return from Fast System Call.</brief>
		<ins x32m="V" x64m="V">
			<mnem>SYSEXIT</mnem>
			<args>void</args>
			<opc openc="NP">0F 35</opc>
			<dscrp>Fast return to privilege level 3 user code.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>SYSEXIT</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + 0F 35</opc>
			<dscrp>Fast return to 64-bit mode privilege level 3 user code.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>SYSRET--Return From Fast System Call.</brief>
		<ins x32m="I" x64m="V">
			<mnem>SYSRET</mnem>
			<args>void</args>
			<opc openc="NP">0F 07</opc>
			<dscrp>Return to compatibility mode from fast system call.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>SYSRET</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + 0F 07</opc>
			<dscrp>Return to 64-bit mode from fast system call.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>TEST--Logical Compare.</brief>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>AL,imm8</args>
			<opc openc="I">A8 ib</opc>
			<dscrp>AND imm8 with AL; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>AX,imm16</args>
			<opc openc="I">A9 iw</opc>
			<dscrp>AND imm16 with AX; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">A9 id</opc>
			<dscrp>AND imm32 with EAX; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>TEST</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + A9 id</opc>
			<dscrp>AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">F6 /0 ib</opc>
			<dscrp>AND imm8 with r/m8; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + F6 /0 ib</opc>
			<dscrp>AND imm8 with r/m8; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">F7 /0 iw</opc>
			<dscrp>AND imm16 with r/m16; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">F7 /0 id</opc>
			<dscrp>AND imm32 with r/m32; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + F7 /0 id</opc>
			<dscrp>AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">84 /r</opc>
			<dscrp>AND r8 with r/m8; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m8*,r8*</args>
			<opc openc="MR">REX + 84 /r</opc>
			<dscrp>AND r8 with r/m8; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">85 /r</opc>
			<dscrp>AND r16 with r/m16; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">85 /r</opc>
			<dscrp>AND r32 with r/m32; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>TEST</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 85 /r</opc>
			<dscrp>AND r64 with r/m64; set SF, ZF, PF according to result.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>TZCNT--Count the Number of Trailing Zero Bits.</brief>
		<ins x32m="V" x64m="V">
			<mnem>TZCNT</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">F3 0F BC /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Count the number of trailing zero bits in r/m16, return result in r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>TZCNT</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">F3 0F BC /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Count the number of trailing zero bits in r/m32, return result in r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>TZCNT</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">F3 REX.W 0F BC /r</opc>
			<cpuid>
				<flag>BMI1</flag>
			</cpuid>
			<dscrp>Count the number of trailing zero bits in r/m64, return result in r64.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UCOMISD--Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UCOMISD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">66 0F 2E /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Compares (unordered) the low doubleprecision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUCOMISD</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.LIG.66.0F.WIG 2E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UCOMISS--Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UCOMISS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">0F 2E /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Compare lower single-precision floating-point value in xmm1 register with lower singleprecision floating-point value in xmm2/mem and set the status flags accordingly.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUCOMISS</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.LIG.0F.WIG 2E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UD2--Undefined Instruction.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UD2</mnem>
			<args>void</args>
			<opc openc="NP">0F 0B</opc>
			<dscrp>Raise invalid opcode exception.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UNPCKHPD--Unpack and Interleave High Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UNPCKHPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 15 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKHPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 15 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKHPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 15 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UNPCKHPS--Unpack and Interleave High Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UNPCKHPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 15 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKHPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 15 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKHPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 15 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UNPCKLPD--Unpack and Interleave Low Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UNPCKLPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 14 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKLPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 14 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves double precision floating-point values low high quadwords of xmm2 and xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKLPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 14 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves double precision floating-point values low high quadwords of ymm2 and ymm3/m256.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>UNPCKLPS--Unpack and Interleave Low Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>UNPCKLPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 14 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKLPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 14 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VUNPCKLPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 14 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VBROADCAST--Broadcast Floating-Point Data.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTSS</mnem>
			<args>xmm1,m32</args>
			<opc openc="RM">VEX.128.66.0F38.W0 18 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Broadcast single-precision floating-point element in mem to four locations in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTSS</mnem>
			<args>ymm1,m32</args>
			<opc openc="RM">VEX.256.66.0F38.W0 18 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Broadcast single-precision floating-point element in mem to eight locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTSD</mnem>
			<args>ymm1,m64</args>
			<opc openc="RM">VEX.256.66.0F38.W0 19 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Broadcast double-precision floating-point element in mem to four locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTF128</mnem>
			<args>ymm1,m128</args>
			<opc openc="RM">VEX.256.66.0F38.W0 1A /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTSS</mnem>
			<args>xmm1,xmm2</args>
			<opc openc="RM">VEX.128.66.0F38.W0 18/r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast the low single-precision floatingpoint element in the source operand to four locations in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTSS</mnem>
			<args>ymm1,xmm2</args>
			<opc openc="RM">VEX.256.66.0F38.W0 18 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTSD</mnem>
			<args>ymm1,xmm2</args>
			<opc openc="RM">VEX.256.66.0F38.W0 19 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast low double-precision floating-point element in the source operand to four locations in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VCVTPH2PS--Convert 16-bit FP Values to Single-Precision FP Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPH2PS</mnem>
			<args>ymm1,xmm2/m128</args>
			<opc openc="RM">VEX.256.66.0F38.W0 13 /r</opc>
			<cpuid>
				<flag>F16C</flag>
			</cpuid>
			<dscrp>Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPH2PS</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.W0 13 /r</opc>
			<cpuid>
				<flag>F16C</flag>
			</cpuid>
			<dscrp>Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VCVTPS2PH--Convert Single-Precision FP value to 16-bit FP value.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPS2PH</mnem>
			<args>xmm1/m128,ymm2,imm8</args>
			<opc openc="MR">VEX.256.66.0F3A.W0 1D /r ib</opc>
			<cpuid>
				<flag>F16C</flag>
			</cpuid>
			<dscrp>Convert eight packed single-precision floating-point value in ymm2 to packed half-precision (16-bit) floating-point value in xmm1/mem. Imm8 provides rounding controls.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VCVTPS2PH</mnem>
			<args>xmm1/m64,xmm2,imm8</args>
			<opc openc="MR">VEX.128.66.0F3A.W0.1D /r ib</opc>
			<cpuid>
				<flag>F16C</flag>
			</cpuid>
			<dscrp>Convert four packed single-precision floating-point value in xmm2 to packed halfprecision (16-bit) floating-point value in xmm1/mem. Imm8 provides rounding controls.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VERR/VERW--Verify a Segment for Reading or Writing.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VERR</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 00 /4</opc>
			<dscrp>Set ZF=1 if segment specified with r/m16 can be read.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VERW</mnem>
			<args>r/m16</args>
			<opc openc="M">0F 00 /5</opc>
			<dscrp>Set ZF=1 if segment specified with r/m16 can be written.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VEXTRACTF128--Extract Packed Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VEXTRACTF128</mnem>
			<args>xmm1/m128,ymm2,imm8</args>
			<opc openc="MR">VEX.256.66.0F3A.W0 19 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/mem.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VEXTRACTI128--Extract packed Integer Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VEXTRACTI128</mnem>
			<args>xmm1/m128,ymm2,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.W0 39 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Extract 128 bits of integer data from ymm2 and store results in xmm1/mem.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>Imm8</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMADD132PD/VFMADD213PD/VFMADD231PD--Fused Multiply-Add of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD132PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 98 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD213PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 A8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD231PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 B8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD132PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 98 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD213PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 A8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD231PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 B8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMADD132PS/VFMADD213PS/VFMADD231PS--Fused Multiply-Add of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD132PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 98 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD213PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 A8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD231PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 B8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD132PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 98 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD213PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 A8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD231PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 B8 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMADD132SD/VFMADD213SD/VFMADD231SD--Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD132SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 99 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD213SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 A9 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD231SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 B9 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMADD132SS/VFMADD213SS/VFMADD231SS--Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD132SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 99 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD213SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 A9 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADD231SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 B9 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD--Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB132PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 96 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB213PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 A6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB231PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 B6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB132PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 96 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB213PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 A6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB231PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 B6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS--Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB132PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 96 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB213PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 A6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB231PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 B6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB132PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 96 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB213PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 A6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMADDSUB231PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 B6 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD--Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD132PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 97 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD213PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 A7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD231PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 B7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD132PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 97 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD213PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 A7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD231PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 B7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS--Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD132PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 97 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD213PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 A7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD231PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 B7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD132PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 97 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD213PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 A7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUBADD231PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 B7 /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMSUB132PD/VFMSUB213PD/VFMSUB231PD--Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB132PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 9A /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB213PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 AA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB231PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 BA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB132PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 9A /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB213PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 AA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB231PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 BA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMSUB132PS/VFMSUB213PS/VFMSUB231PS--Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB132PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 9A /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB213PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 AA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB231PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 BA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB132PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 9A /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB213PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 AA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB231PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 BA /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMSUB132SD/VFMSUB213SD/VFMSUB231SD--Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB132SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 9B /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB213SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 AB /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB231SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 BB /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFMSUB132SS/VFMSUB213SS/VFMSUB231SS--Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB132SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 9B /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB213SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 AB /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFMSUB231SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 BB /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMADD132PD/VFNMADD213PD/VFNMADD231PD--Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD132PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 9C /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD213PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 AC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD231PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 BC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD132PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 9C /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD213PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 AC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD231PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 BC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMADD132PS/VFNMADD213PS/VFNMADD231PS--Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD132PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 9C /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD213PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 AC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD231PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 BC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD132PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 9C /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD213PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 AC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD231PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 BC /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMADD132SD/VFNMADD213SD/VFNMADD231SD--Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD132SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 9D /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD213SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 AD /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD231SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 BD /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMADD132SS/VFNMADD213SS/VFNMADD231SS--Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD132SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 9D /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD213SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 AD /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMADD231SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 BD /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD--Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB132PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 9E /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB213PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 AE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB231PD</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W1 BE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB132PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 9E /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB213PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 AE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB231PD</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W1 BE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS--Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB132PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 9E /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB213PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 AE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB231PS</mnem>
			<args>xmm0,xmm1,xmm2/m128</args>
			<opc openc="A">VEX.DDS.128.66.0F38.W0 BE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB132PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 9E /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB213PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 AE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB231PS</mnem>
			<args>ymm0,ymm1,ymm2/m256</args>
			<opc openc="A">VEX.DDS.256.66.0F38.W0 BE /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD--Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB132SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 9F /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB213SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 AF /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB231SD</mnem>
			<args>xmm0,xmm1,xmm2/m64</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W1 BF /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS--Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB132SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 9F /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB213SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 AF /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VFNMSUB231SS</mnem>
			<args>xmm0,xmm1,xmm2/m32</args>
			<opc openc="A">VEX.DDS.LIG.128.66.0F38.W0 BF /r</opc>
			<cpuid>
				<flag>FMA</flag>
			</cpuid>
			<dscrp>Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VGATHERDPD/VGATHERQPD--Gather Packed DP FP Values Using Signed Dword/Qword Indices.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERDPD</mnem>
			<args>xmm1,vm32x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W1 92 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERQPD</mnem>
			<args>xmm1,vm64x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W1 93 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERDPD</mnem>
			<args>ymm1,vm32x,ymm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W1 92 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERQPD</mnem>
			<args>ymm1,vm64y,ymm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W1 93 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMV">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>BaseReg(R): VSIB:base,VectorReg(R): VSIB:index</oprnd2>
			<oprnd3>VEX.vvvv(r,w)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VGATHERDPS/VGATHERQPS--Gather Packed SP FP values Using Signed Dword/Qword Indices.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERDPS</mnem>
			<args>xmm1,vm32x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W0 92 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERQPS</mnem>
			<args>xmm1,vm64x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W0 93 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERDPS</mnem>
			<args>ymm1,vm32y,ymm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W0 92 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32y, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VGATHERQPS</mnem>
			<args>xmm1,vm64y,xmm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W0 93 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>BaseReg(R): VSIB:base,VectorReg(R): VSIB:index</oprnd2>
			<oprnd3>VEX.vvvv(r,w)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPGATHERDD/VPGATHERQD--Gather Packed Dword Values Using Signed Dword/Qword Indices.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERDD</mnem>
			<args>xmm1,vm32x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W0 90 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERQD</mnem>
			<args>xmm1,vm64x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W0 91 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERDD</mnem>
			<args>ymm1,vm32y,ymm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W0 90 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERQD</mnem>
			<args>xmm1,vm64y,xmm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W0 91 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<oprndenc openc="RMV">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>BaseReg(R): VSIB:base,VectorReg(R): VSIB:index</oprnd2>
			<oprnd3>VEX.vvvv(r,w)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPGATHERDQ/VPGATHERQQ--Gather Packed Qword Values Using Signed Dword/Qword Indices.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERDQ</mnem>
			<args>xmm1,vm32x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W1 90 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERQQ</mnem>
			<args>xmm1,vm64x,xmm2</args>
			<opc openc="RMV">VEX.DDS.128.66.0F38.W1 91 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERDQ</mnem>
			<args>ymm1,vm32x,ymm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W1 90 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPGATHERQQ</mnem>
			<args>ymm1,vm64y,ymm2</args>
			<opc openc="RMV">VEX.DDS.256.66.0F38.W1 91 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>BaseReg(R): VSIB:base,VectorReg(R): VSIB:index</oprnd2>
			<oprnd3>VEX.vvvv(r,w)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VINSERTF128--Insert Packed Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VINSERTF128</mnem>
			<args>ymm1,ymm2,xmm3/m128,imm8</args>
			<opc openc="RVM">VEX.NDS.256.66.0F3A.W0 18 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Insert a single precision floating-point value selected by imm8 from xmm3/m128 into ymm2 at the specified destination element specified by imm8 and zero out destination elements in ymm1 as indicated in imm8.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VINSERTI128--Insert Packed Integer Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VINSERTI128</mnem>
			<args>ymm1,ymm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.W0 38 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Insert 128-bits of integer data from xmm3/mem and the remaining values from ymm2 into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>Imm8</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VMASKMOV--Conditional SIMD Packed Loads and Stores.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPS</mnem>
			<args>xmm1,xmm2,m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 2C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPS</mnem>
			<args>ymm1,ymm2,m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 2C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPD</mnem>
			<args>xmm1,xmm2,m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 2D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPD</mnem>
			<args>ymm1,ymm2,m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 2D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPS</mnem>
			<args>m128,xmm1,xmm2</args>
			<opc openc="MVR">VEX.NDS.128.66.0F38.W0 2E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally store packed single-precision values from xmm2 using mask in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPS</mnem>
			<args>m256,ymm1,ymm2</args>
			<opc openc="MVR">VEX.NDS.256.66.0F38.W0 2E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally store packed single-precision values from ymm2 using mask in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPD</mnem>
			<args>m128,xmm1,xmm2</args>
			<opc openc="MVR">VEX.NDS.128.66.0F38.W0 2F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally store packed double-precision values from xmm2 using mask in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VMASKMOVPD</mnem>
			<args>m256,ymm1,ymm2</args>
			<opc openc="MVR">VEX.NDS.256.66.0F38.W0 2F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Conditionally store packed double-precision values from ymm2 using mask in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MVR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:reg(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPBLENDD--Blend Packed Dwords.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPBLENDD</mnem>
			<args>xmm1,xmm2,xmm3/m128,imm8</args>
			<opc openc="RVMI">VEX.NDS.128.66.0F3A.W0 02 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBLENDD</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.W0 02 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>Imm8</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPBROADCAST--Broadcast Integer Data.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTB</mnem>
			<args>xmm1,xmm2/m8</args>
			<opc openc="RM">VEX.128.66.0F38.W0 78 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a byte integer in the source operand to sixteen locations in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTB</mnem>
			<args>ymm1,xmm2/m8</args>
			<opc openc="RM">VEX.256.66.0F38.W0 78 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a byte integer in the source operand to thirtytwo locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTW</mnem>
			<args>xmm1,xmm2/m16</args>
			<opc openc="RM">VEX.128.66.0F38.W0 79 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a word integer in the source operand to eight locations in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTW</mnem>
			<args>ymm1,xmm2/m16</args>
			<opc openc="RM">VEX.256.66.0F38.W0 79 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a word integer in the source operand to sixteen locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTD</mnem>
			<args>xmm1,xmm2/m32</args>
			<opc openc="RM">VEX.128.66.0F38.W0 58 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a dword integer in the source operand to four locations in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTD</mnem>
			<args>ymm1,xmm2/m32</args>
			<opc openc="RM">VEX.256.66.0F38.W0 58 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a dword integer in the source operand to eight locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTQ</mnem>
			<args>xmm1,xmm2/m64</args>
			<opc openc="RM">VEX.128.66.0F38.W0 59 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a qword element in mem to two locations in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPBROADCASTQ</mnem>
			<args>ymm1,xmm2/m64</args>
			<opc openc="RM">VEX.256.66.0F38.W0 59 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast a qword element in mem to four locations in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VBROADCASTI128</mnem>
			<args>ymm1,m128</args>
			<opc openc="RM">VEX.256.66.0F38.W0 5A /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERMD--Full Doublewords Element Permutation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERMD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 36 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Permute doublewords in ymm3/m256 using indexes in ymm2 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERMPD--Permute Double-Precision Floating-Point Elements.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERMPD</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.W1 01 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Permute double-precision floating-point elements in ymm2/m256 using indexes in imm8 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>Imm8</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERMPS--Permute Single-Precision Floating-Point Elements.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERMPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 16 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Permute single-precision floating-point elements in ymm3/m256 using indexes in ymm2 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERMQ--Qwords Element Permutation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERMQ</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.W1 00 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Permute qwords in ymm2/m256 using indexes in imm8 and store the result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>Imm8</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERM2I128--Permute Integer Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERM2I128</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.W0 46 /r ib</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>Imm8</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERMILPD--Permute Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 0D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute double-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 0D /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute double-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPD</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.W0 05 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute double-precision floating-point values in xmm2/mem using controls from imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPD</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.W0 05 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute double-precision floating-point values in ymm2/mem using controls from imm8.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERMILPS--Permute Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 0C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute single-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPS</mnem>
			<args>xmm1,xmm2/m128,imm8</args>
			<opc openc="RMI">VEX.128.66.0F3A.W0 04 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute single-precision floating-point values in xmm2/mem using controls from imm8 and store result in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 0C /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute single-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPERMILPS</mnem>
			<args>ymm1,ymm2/m256,imm8</args>
			<opc openc="RMI">VEX.256.66.0F3A.W0 04 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute single-precision floating-point values in ymm2/mem using controls from imm8 and store result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>imm8(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPERM2F128--Permute Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPERM2F128</mnem>
			<args>ymm1,ymm2,ymm3/m256,imm8</args>
			<opc openc="RVMI">VEX.NDS.256.66.0F3A.W0 06 /r ib</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVMI">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>imm8(r)</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPMASKMOV--Conditional SIMD Integer Packed Loads and Stores.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVD</mnem>
			<args>xmm1,xmm2,m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 8C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally load dword values from m128 using mask in xmm2 and store in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVD</mnem>
			<args>ymm1,ymm2,m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 8C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally load dword values from m256 using mask in ymm2 and store in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVQ</mnem>
			<args>xmm1,xmm2,m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W1 8C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally load qword values from m128 using mask in xmm2 and store in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVQ</mnem>
			<args>ymm1,ymm2,m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W1 8C /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally load qword values from m256 using mask in ymm2 and store in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVD</mnem>
			<args>m128,xmm1,xmm2</args>
			<opc openc="MVR">VEX.NDS.128.66.0F38.W0 8E /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally store dword values from xmm2 using mask in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVD</mnem>
			<args>m256,ymm1,ymm2</args>
			<opc openc="MVR">VEX.NDS.256.66.0F38.W0 8E /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally store dword values from ymm2 using mask in ymm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVQ</mnem>
			<args>m128,xmm1,xmm2</args>
			<opc openc="MVR">VEX.NDS.128.66.0F38.W1 8E /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally store qword values from xmm2 using mask in xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPMASKMOVQ</mnem>
			<args>m256,ymm1,ymm2</args>
			<opc openc="MVR">VEX.NDS.256.66.0F38.W1 8E /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Conditionally store qword values from ymm2 using mask in ymm1.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MVR">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:reg(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPSLLVD/VPSLLVQ--Variable Bit Shift Left Logical.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLVD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 47 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLVQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W1 47 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLVD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 47 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSLLVQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W1 47 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPSRAVD--Variable Bit Shift Right Arithmetic.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAVD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 46 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in the sign bits.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRAVD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 46 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in the sign bits.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VPSRLVD/VPSRLVQ--Variable Bit Shift Right Logical.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLVD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W0 45 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLVQ</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F38.W1 45 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLVD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W0 45 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VPSRLVQ</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F38.W1 45 /r</opc>
			<cpuid>
				<flag>AVX2</flag>
			</cpuid>
			<dscrp>Shift bits in quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s.</dscrp>
		</ins>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VTESTPD/VTESTPS--Packed Bit Test.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VTESTPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.W0 0E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VTESTPS</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F38.W0 0E /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VTESTPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">VEX.128.66.0F38.W0 0F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VTESTPD</mnem>
			<args>ymm1,ymm2/m256</args>
			<opc openc="RM">VEX.256.66.0F38.W0 0F /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VZEROALL--Zero All YMM Registers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VZEROALL</mnem>
			<args>void</args>
			<opc openc="NP">VEX.256.0F.WIG 77</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero all YMM registers.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>VZEROUPPER--Zero Upper Bits of YMM Registers.</brief>
		<ins x32m="V" x64m="V">
			<mnem>VZEROUPPER</mnem>
			<args>void</args>
			<opc openc="NP">VEX.128.0F.WIG 77</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Zero upper 128 bits of all YMM registers.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>WAIT/FWAIT--Wait.</brief>
		<ins x32m="V" x64m="V">
			<mnem>WAIT</mnem>
			<args>void</args>
			<opc openc="NP">9B</opc>
			<dscrp>Check pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>FWAIT</mnem>
			<args>void</args>
			<opc openc="NP">9B</opc>
			<dscrp>Check pending unmasked floating-point exceptions.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>WBINVD--Write Back and Invalidate Cache.</brief>
		<ins x32m="V" x64m="V">
			<mnem>WBINVD</mnem>
			<args>void</args>
			<opc openc="NP">0F 09</opc>
			<dscrp>Write back and flush Internal caches; initiate writing-back and flushing of external caches.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>WRFSBASE/WRGSBASE--Write FS/GS Segment Base.</brief>
		<ins x32m="I" x64m="V">
			<mnem>WRFSBASE</mnem>
			<args>r32</args>
			<opc openc="M">F3 0F AE /2</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the FS base address with the 32-bit value in the source register.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>WRFSBASE</mnem>
			<args>r64</args>
			<opc openc="M">F3 REX.W 0F AE /2</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the FS base address with the 64-bit value in the source register.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>WRGSBASE</mnem>
			<args>r32</args>
			<opc openc="M">F3 0F AE /3</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the GS base address with the 32-bit value in the source register.</dscrp>
		</ins>
		<ins x32m="I" x64m="V">
			<mnem>WRGSBASE</mnem>
			<args>r64</args>
			<opc openc="M">F3 REX.W 0F AE /3</opc>
			<cpuid>
				<flag>FSGSBASE</flag>
			</cpuid>
			<dscrp>Load the GS base address with the 64-bit value in the source register.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>WRMSR--Write to Model Specific Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>WRMSR</mnem>
			<args>void</args>
			<opc openc="NP">0F 30</opc>
			<dscrp>Write the value in EDX:EAX to MSR specified by ECX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>WRPKRU--Write Data to User Page Key Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>WRPKRU</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 EF</opc>
			<cpuid>
				<flag>OSPKE</flag>
			</cpuid>
			<dscrp>Writes EAX into PKRU.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XACQUIRE/XRELEASE--Hardware Lock Elision Prefix Hints.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XACQUIRE</mnem>
			<args>void</args>
			<opc openc="">F2</opc>
			<cpuid>
				<flag>HLE1</flag>
			</cpuid>
			<dscrp>A hint used with an 'XACQUIRE-enabled' instruction to start lock elision on the instruction memory operand address.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XRELEASE</mnem>
			<args>void</args>
			<opc openc="">F3</opc>
			<cpuid>
				<flag>HLE</flag>
			</cpuid>
			<dscrp>A hint used with an 'XRELEASE-enabled' instruction to end lock elision on the instruction memory operand address.</dscrp>
		</ins>
	</common>
	<common>
		<brief>XABORT--Transactional Abort.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XABORT</mnem>
			<args>imm8</args>
			<opc openc="A">C6 F8 ib</opc>
			<cpuid>
				<flag>RTM</flag>
			</cpuid>
			<dscrp>Causes an RTM abort if in RTM execution.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>imm8(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XADD--Exchange and Add.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XADD</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">0F C0 /r</opc>
			<dscrp>Exchange r8 and r/m8; load sum into r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XADD</mnem>
			<args>r/m8*,r8*</args>
			<opc openc="MR">REX + 0F C0 /r</opc>
			<dscrp>Exchange r8 and r/m8; load sum into r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XADD</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">0F C1 /r</opc>
			<dscrp>Exchange r16 and r/m16; load sum into r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XADD</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">0F C1 /r</opc>
			<dscrp>Exchange r32 and r/m32; load sum into r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XADD</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 0F C1 /r</opc>
			<dscrp>Exchange r64 and r/m64; load sum into r/m64.</dscrp>
		</ins>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(W)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XBEGIN--Transactional Begin.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XBEGIN</mnem>
			<args>rel16</args>
			<opc openc="A">C7 F8</opc>
			<cpuid>
				<flag>RTM</flag>
			</cpuid>
			<dscrp>Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XBEGIN</mnem>
			<args>rel32</args>
			<opc openc="A">C7 F8</opc>
			<cpuid>
				<flag>RTM</flag>
			</cpuid>
			<dscrp>Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>Offset</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XCHG--Exchange Register/Memory with Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>AX,r16</args>
			<opc openc="O">90+rw</opc>
			<dscrp>Exchange r16 with AX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r16,AX</args>
			<opc openc="O">90+rw</opc>
			<dscrp>Exchange AX with r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>EAX,r32</args>
			<opc openc="O">90+rd</opc>
			<dscrp>Exchange r32 with EAX.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XCHG</mnem>
			<args>RAX,r64</args>
			<opc openc="O">REX.W + 90+rd</opc>
			<dscrp>Exchange r64 with RAX.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r32,EAX</args>
			<opc openc="O">90+rd</opc>
			<dscrp>Exchange EAX with r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XCHG</mnem>
			<args>r64,RAX</args>
			<opc openc="O">REX.W + 90+rd</opc>
			<dscrp>Exchange RAX with r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">86 /r</opc>
			<dscrp>Exchange r8 (byte register) with byte from r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XCHG</mnem>
			<args>r/m8*,r8*</args>
			<opc openc="MR">REX + 86 /r</opc>
			<dscrp>Exchange r8 (byte register) with byte from r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">86 /r</opc>
			<dscrp>Exchange byte from r/m8 with r8 (byte register).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XCHG</mnem>
			<args>r8*,r/m8*</args>
			<opc openc="RM">REX + 86 /r</opc>
			<dscrp>Exchange byte from r/m8 with r8 (byte register).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">87 /r</opc>
			<dscrp>Exchange r16 with word from r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">87 /r</opc>
			<dscrp>Exchange word from r/m16 with r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">87 /r</opc>
			<dscrp>Exchange r32 with doubleword from r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XCHG</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 87 /r</opc>
			<dscrp>Exchange r64 with quadword from r/m64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XCHG</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">87 /r</opc>
			<dscrp>Exchange doubleword from r/m32 with r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XCHG</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 87 /r</opc>
			<dscrp>Exchange quadword from r/m64 with r64.</dscrp>
		</ins>
		<oprndenc openc="O">
			<oprnd1>AX/EAX/RAX(r,w)</oprnd1>
			<oprnd2>opcode + rd(r,w)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="O">
			<oprnd1>opcode + rd(r,w)</oprnd1>
			<oprnd2>AX/EAX/RAX(r,w)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XEND--Transactional End.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XEND</mnem>
			<args>void</args>
			<opc openc="A">0F 01 D5</opc>
			<cpuid>
				<flag>RTM</flag>
			</cpuid>
			<dscrp>Specifies the end of an RTM code region.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XGETBV--Get Value of Extended Control Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XGETBV</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 D0</opc>
			<dscrp>Reads an XCR specified by ECX into EDX:EAX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XLAT/XLATB--Table Look-up Translation.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XLAT</mnem>
			<args>m8</args>
			<opc openc="NP">D7</opc>
			<dscrp>Set AL to memory byte DS:[(E)BX + unsigned AL].</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XLATB</mnem>
			<args>void</args>
			<opc openc="NP">D7</opc>
			<dscrp>Set AL to memory byte DS:[(E)BX + unsigned AL].</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XLATB</mnem>
			<args>void</args>
			<opc openc="NP">REX.W + D7</opc>
			<dscrp>Set AL to memory byte [RBX + unsigned AL].</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XOR--Logical Exclusive OR.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>AL,imm8</args>
			<opc openc="I">34 ib</opc>
			<dscrp>AL XOR imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>AX,imm16</args>
			<opc openc="I">35 iw</opc>
			<dscrp>AX XOR imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>EAX,imm32</args>
			<opc openc="I">35 id</opc>
			<dscrp>EAX XOR imm32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>RAX,imm32</args>
			<opc openc="I">REX.W + 35 id</opc>
			<dscrp>RAX XOR imm32 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m8,imm8</args>
			<opc openc="MI">80 /6 ib</opc>
			<dscrp>r/m8 XOR imm8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m8*,imm8</args>
			<opc openc="MI">REX + 80 /6 ib</opc>
			<dscrp>r/m8 XOR imm8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m16,imm16</args>
			<opc openc="MI">81 /6 iw</opc>
			<dscrp>r/m16 XOR imm16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m32,imm32</args>
			<opc openc="MI">81 /6 id</opc>
			<dscrp>r/m32 XOR imm32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m64,imm32</args>
			<opc openc="MI">REX.W + 81 /6 id</opc>
			<dscrp>r/m64 XOR imm32 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m16,imm8</args>
			<opc openc="MI">83 /6 ib</opc>
			<dscrp>r/m16 XOR imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m32,imm8</args>
			<opc openc="MI">83 /6 ib</opc>
			<dscrp>r/m32 XOR imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m64,imm8</args>
			<opc openc="MI">REX.W + 83 /6 ib</opc>
			<dscrp>r/m64 XOR imm8 (sign-extended).</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m8,r8</args>
			<opc openc="MR">30 /r</opc>
			<dscrp>r/m8 XOR r8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m8*,r8*</args>
			<opc openc="MR">REX + 30 /r</opc>
			<dscrp>r/m8 XOR r8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m16,r16</args>
			<opc openc="MR">31 /r</opc>
			<dscrp>r/m16 XOR r16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m32,r32</args>
			<opc openc="MR">31 /r</opc>
			<dscrp>r/m32 XOR r32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r/m64,r64</args>
			<opc openc="MR">REX.W + 31 /r</opc>
			<dscrp>r/m64 XOR r64.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r8,r/m8</args>
			<opc openc="RM">32 /r</opc>
			<dscrp>r8 XOR r/m8.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r8*,r/m8*</args>
			<opc openc="RM">REX + 32 /r</opc>
			<dscrp>r8 XOR r/m8.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r16,r/m16</args>
			<opc openc="RM">33 /r</opc>
			<dscrp>r16 XOR r/m16.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XOR</mnem>
			<args>r32,r/m32</args>
			<opc openc="RM">33 /r</opc>
			<dscrp>r32 XOR r/m32.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XOR</mnem>
			<args>r64,r/m64</args>
			<opc openc="RM">REX.W + 33 /r</opc>
			<dscrp>r64 XOR r/m64.</dscrp>
		</ins>
		<oprndenc openc="I">
			<oprnd1>AL/AX/EAX/RAX</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MI">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>imm8(r)/16/32</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="MR">
			<oprnd1>ModRM:r/m(r,w)</oprnd1>
			<oprnd2>ModRM:reg(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XORPD--Bitwise Logical XOR for Double-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XORPD</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">66 0F 57 /r</opc>
			<cpuid>
				<flag>SSE2</flag>
			</cpuid>
			<dscrp>Bitwise exclusive-OR of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VXORPD</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.66.0F.WIG 57 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VXORPD</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.66.0F.WIG 57 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XORPS--Bitwise Logical XOR for Single-Precision Floating-Point Values.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XORPS</mnem>
			<args>xmm1,xmm2/m128</args>
			<opc openc="RM">0F 57 /r</opc>
			<cpuid>
				<flag>SSE</flag>
			</cpuid>
			<dscrp>Bitwise exclusive-OR of xmm2/m128 and xmm1.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VXORPS</mnem>
			<args>xmm1,xmm2,xmm3/m128</args>
			<opc openc="RVM">VEX.NDS.128.0F.WIG 57 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical XOR of packed singleprecision floating-point values in xmm2 and xmm3/mem.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>VXORPS</mnem>
			<args>ymm1,ymm2,ymm3/m256</args>
			<opc openc="RVM">VEX.NDS.256.0F.WIG 57 /r</opc>
			<cpuid>
				<flag>AVX</flag>
			</cpuid>
			<dscrp>Return the bitwise logical XOR of packed singleprecision floating-point values in ymm2 and ymm3/mem.</dscrp>
		</ins>
		<oprndenc openc="RM">
			<oprnd1>ModRM:reg(r,w)</oprnd1>
			<oprnd2>ModRM:r/m(r)</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
		<oprndenc openc="RVM">
			<oprnd1>ModRM:reg(w)</oprnd1>
			<oprnd2>VEX.vvvv(r)</oprnd2>
			<oprnd3>ModRM:r/m(r)</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XRSTOR--Restore Processor Extended States.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XRSTOR</mnem>
			<args>mem</args>
			<opc openc="M">0F AE /5</opc>
			<dscrp>Restore state components specified by EDX:EAX from mem.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XRSTOR64</mnem>
			<args>mem</args>
			<opc openc="M">REX.W+ 0F AE /5</opc>
			<dscrp>Restore state components specified by EDX:EAX from mem.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XRSTORS--Restore Processor Extended States Supervisor.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XRSTORS</mnem>
			<args>mem</args>
			<opc openc="M">0F C7 /3</opc>
			<dscrp>Restore state components specified by EDX:EAX from mem.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XRSTORS64</mnem>
			<args>mem</args>
			<opc openc="M">REX.W+ 0F C7 /3</opc>
			<dscrp>Restore state components specified by EDX:EAX from mem.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(r)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XSAVE--Save Processor Extended States.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XSAVE</mnem>
			<args>mem</args>
			<opc openc="M">0F AE /4</opc>
			<dscrp>Save state components specified by EDX:EAX to mem.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XSAVE64</mnem>
			<args>mem</args>
			<opc openc="M">REX.W+ 0F AE /4</opc>
			<dscrp>Save state components specified by EDX:EAX to mem.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XSAVEC--Save Processor Extended States with Compaction.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XSAVEC</mnem>
			<args>mem</args>
			<opc openc="M">0F C7 /4</opc>
			<dscrp>Save state components specified by EDX:EAX to mem with compaction.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XSAVEC64</mnem>
			<args>mem</args>
			<opc openc="M">REX.W+ 0F C7 /4</opc>
			<dscrp>Save state components specified by EDX:EAX to mem with compaction.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XSAVEOPT--Save Processor Extended States Optimized.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XSAVEOPT</mnem>
			<args>mem</args>
			<opc openc="M">0F AE /6</opc>
			<cpuid>
				<flag>XSAVEOPT</flag>
			</cpuid>
			<dscrp>Save state components specified by EDX:EAX to mem, optimizing if possible.</dscrp>
		</ins>
		<ins x32m="V" x64m="V">
			<mnem>XSAVEOPT64</mnem>
			<args>mem</args>
			<opc openc="M">REX.W + 0F AE /6</opc>
			<cpuid>
				<flag>XSAVEOPT</flag>
			</cpuid>
			<dscrp>Save state components specified by EDX:EAX to mem, optimizing if possible.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XSAVES--Save Processor Extended States Supervisor.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XSAVES</mnem>
			<args>mem</args>
			<opc openc="M">0F C7 /5</opc>
			<dscrp>Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.</dscrp>
		</ins>
		<ins x32m="NE" x64m="V">
			<mnem>XSAVES64</mnem>
			<args>mem</args>
			<opc openc="M">REX.W+ 0F C7 /5</opc>
			<dscrp>Save state components specified by EDX:EAX to mem with compaction, optimizing if possible.</dscrp>
		</ins>
		<oprndenc openc="M">
			<oprnd1>ModRM:r/m(w)</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XSETBV--Set Extended Control Register.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XSETBV</mnem>
			<args>void</args>
			<opc openc="NP">0F 01 D1</opc>
			<dscrp>Write the value in EDX:EAX to the XCR specified by ECX.</dscrp>
		</ins>
		<oprndenc openc="NP">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
	<common>
		<brief>XTEST--Test If In Transactional Execution.</brief>
		<ins x32m="V" x64m="V">
			<mnem>XTEST</mnem>
			<args>void</args>
			<opc openc="A">0F 01 D6</opc>
			<cpuid>
				<flag>HLE</flag>
				<flag>RTM</flag>
			</cpuid>
			<dscrp>Test if executing in a transactional region.</dscrp>
		</ins>
		<oprndenc openc="A">
			<oprnd1>NA</oprnd1>
			<oprnd2>NA</oprnd2>
			<oprnd3>NA</oprnd3>
			<oprnd4>NA</oprnd4>
		</oprndenc>
	</common>
</instrs>
